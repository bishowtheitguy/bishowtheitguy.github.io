{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#backend-language","title":"Backend Language","text":"<ul> <li> <p> Python</p> </li> <li> <p> Laravel</p> </li> <li> <p> Go</p> </li> <li> <p> Java</p> </li> </ul> Note <p>Given the increasing prominence of artificial intelligence (AI) and its integration into backend systems, two languages with significant potential for the future of backend development in the AI domain are Python and Golang (Go).</p> <p>Python:</p> <p>Python has already established itself as a dominant language in AI and machine learning (ML) development due to its simplicity, versatility, and extensive libraries like <code>TensorFlow</code>, <code>PyTorch</code>, and <code>scikit-learn</code>. Its ease of use makes it ideal for rapid prototyping and experimentation, while its performance can be enhanced through libraries like <code>NumPy</code> and <code>Cython</code>.</p> <p>Golang (Go):</p> <p>Go is gaining traction in the AI and backend development communities due to its speed, concurrency support, and strong built-in standard library. Go's simplicity and efficiency make it well-suited for building scalable backend systems that handle AI workloads efficiently. Additionally, frameworks like <code>TensorFlow</code> and <code>gorgonia</code> provide Go bindings for AI development.</p> <p>By learning Python and Golang, you'll be well-equipped to tackle backend development tasks in the evolving landscape of AI-driven applications and systems. These languages offer complementary strengths and are likely to remain relevant in the future of AI-powered backend development.</p>"},{"location":"#question","title":"Question","text":"<p>is try catch is different in js and python beacuse i see try except in python</p> <p>Yes, try-catch in JavaScript and try-except in Python are different in syntax and usage, although they serve the same purpose of handling exceptions.</p>"},{"location":"#javascript-try-catch","title":"JavaScript Try-Catch","text":"<p>In JavaScript, the try-catch statement is used to handle exceptions. It consists of a try block where the code that might throw an exception is placed, and a catch block where the error is handled. Optionally, a finally block can be added to execute code regardless of whether an exception occurred or not.</p> <pre><code>try {\n  // Code that might throw an exception\n} catch (error) {\n  // Handle the error\n} finally {\n  // Code that runs regardless of the outcome\n}\n</code></pre>"},{"location":"#python-try-except","title":"Python Try-Except","text":"<p>In Python, the try-except statement is used for exception handling. It also includes a try block for code that might raise an exception, an except block to handle the exception, and an optional else block to execute code if no exception occurs. Like JavaScript, Python also has a finally block for code that should always run.</p> <pre><code>try:\n    # Code that might raise an exception\nexcept ExceptionType:\n    # Handle the exception\nelse:\n    # Code that runs if no exception occurs\nfinally:\n    # Code that runs regardless of the outcome\n</code></pre> <p>Key Differences</p> <ul> <li> <p>Syntax: The most obvious difference is the use of catch in JavaScript versus except in Python.</p> </li> <li> <p>Else Block: Python has an else block that allows code to run if no exception occurs, which is not available in JavaScript.</p> </li> <li> <p>Exception Handling: Both languages handle exceptions similarly, but Python's except block can specify the type of exception to catch, similar to Java.</p> </li> </ul> <p>Overall, while both constructs serve the same purpose, their syntax and additional features differ between JavaScript and Python.</p>"},{"location":"tags/","title":"Tools","text":""},{"location":"tags/#tools","title":"Tools","text":""},{"location":"FP/intro/","title":"FP","text":""},{"location":"OOP/intro/","title":"Intro","text":""},{"location":"OOP/intro/#first-class-functions","title":"First-class functions","text":"<p>Functions in Python are first-class objects.</p> <p>Functions in Python are first-class objects.</p> Reference <ul> <li>Fluent Python by Luciano Ramalho, pg:139</li> </ul>"},{"location":"OOP/intro/#higher-order-functions","title":"Higher-order functions","text":"<p>A function that takes a function as argument or returns a function as result is a higher-order function.</p> Reference <ul> <li>Fluent Python by Luciano Ramalho, pg:139</li> </ul>"},{"location":"OOP/intro/#inheritance","title":"Inheritance","text":"<p>There are three types of relationships between objects:</p> <ol> <li>association,</li> <li>composition,</li> <li>aggregation.</li> </ol> Reference <ul> <li>Python 3 Object-oriented Programming Second Edition by Dusty Phillips - pg: 14</li> </ul>"},{"location":"OOP/intro/#data-serialization","title":"Data Serialization","text":"<p>Data serialization is the concept of converting structured data into a format that allows it to be shared or stored\u2014retaining the information necessary to reconstruct the object in memory at the receiving end of the transmission (or upon read from storage).</p> <p>In some cases, the secondary intent of data serialization is to minimize the size of the serialized data, which then minimizes disk space or bandwidth requirements.</p> Reference <ul> <li>The Hitchhiker's Guide to Python by Kenneth Reitz &amp; Tanya Schlusser, pg:243</li> </ul>"},{"location":"OOP/intro/#python-data-type","title":"PYTHON DATA TYPE","text":"<p>Python comes with two helpful functions that assist you in exploring the language:</p> <ul> <li><code>dir(name)</code></li> <li><code>help(name)</code>.</li> </ul> <p><code>dir(name)</code> tells you all of the names available in the object identified by name.</p> <p>Python supports many powerful data types. Superficially, these look like their counterparts in other programming languages, but in Python they often come with super powers. Everything in Python is an object and, therefore, has methods. This means that you can perform a host of operations on any variable. The built-in <code>dir()</code> and <code>help()</code> functions will reveal all.</p> <p>You need to be aware of some underlying concepts in Python. First, Python variables are just names. You create variable names by assigning them to objects that are instances of types. Variables do not, of themselves, have a type; it is the object to which they are bound that has a type. The name is just a label and, as such, it can be reassigned to a completely different object. Assignment is performed using <code>=</code>, so assigning a value to a variable looks like this:</p> <pre><code>aVariable = aValue\n</code></pre> <p>This code binds the value aValue to the variable name aVariable and, if the name does not already exist, the interpreter adds the name to the appropriate namespace.</p> <p>The distinction between a variable and its underlying value (an object) is thus crucial in Python. You can test variables for equality using a double equal sign (<code>==</code>) and object identity (that is, if two names refer to the same object) is compared using the is operator, as shown:</p> <pre><code>&gt;&gt;&gt; aString = 'I love spam'\n&gt;&gt;&gt; anotherString = 'I love spam'\n\n&gt;&gt;&gt; anInt = 6\n&gt;&gt;&gt; intAlias = anInt\n&gt;&gt;&gt; aString == anotherString # test equality of value\nTrue\n&gt;&gt;&gt; aString is anotherString # test object identity\nFalse\n&gt;&gt;&gt; anInt == intAlias # same value\nTrue\n&gt;&gt;&gt; anInt is intAlias # also same object identity\nTrue\n</code></pre> <p>Python groups types according to how you can use them. For example, all types are either categorized as mutable or immutable. If a type is immutable, it means you can't change an object of that type once it's created. You can create a new data item and assign it to the same variable, but you cannot change the original immutable value.</p> <p>Python also supports several collection types, sometimes referred to as sequences.</p>"},{"location":"OOP/intro/#numeric-types-integer-and-float","title":"Numeric Types: Integer and Float","text":""},{"location":"OOP/intro/#the-boolean-type","title":"The Boolean Type","text":""},{"location":"OOP/intro/#the-none-type","title":"The None Type","text":"<p>The <code>None</code> type represents a <code>null</code> object. There is only one <code>None</code> object in the Python environment, and all references to None use that same single instance.</p>"},{"location":"OOP/intro/#collection-types","title":"Collection Types","text":"<p>As already mentioned Python has several types representing different kinds of <code>collections</code> or <code>sequences</code>. These are: <code>strings</code>, <code>bytes</code>, <code>tuples</code>, <code>lists</code>, <code>dictionaries</code> and <code>sets</code>.</p>"},{"location":"OOP/intro/#strings","title":"Strings","text":""},{"location":"OOP/intro/#bytes-and-bytearrays","title":"Bytes and ByteArrays","text":""},{"location":"OOP/intro/#tuples","title":"Tuples","text":""},{"location":"OOP/intro/#lists","title":"Lists","text":""},{"location":"OOP/intro/#dictionaries","title":"Dictionaries","text":""},{"location":"OOP/intro/#sets","title":"Sets","text":"Reference <ul> <li>Python Projects by Laura Cassel, Alan Gauld: pg-3</li> </ul>"},{"location":"OOP/intro/#class","title":"Class","text":"<p>The most basic idea of a class is that it encapsulates the behavior of an object, while an instance of the class represents the data for the object.</p> Reference <ul> <li>Pro Python by Marty Alchin: pg-103</li> </ul>"},{"location":"blog/","title":"Index","text":""},{"location":"blog/#blog","title":"Blog","text":""},{"location":"dsa/fibonacci/","title":"Fibonacci Example","text":""},{"location":"dsa/fibonacci/#example-of-solving-a-problem-thoughtfully-fibonacci-example","title":"Example of Solving a Problem Thoughtfully (Fibonacci Example):","text":"<p>Problem: Find the <code>nth</code> Fibonacci number.</p>"},{"location":"dsa/fibonacci/#python","title":"Python","text":""},{"location":"dsa/fibonacci/#1-understanding","title":"1. Understanding:","text":"<ul> <li>Fibonacci numbers follow the recurrence relation: <code>F(n) = F(n-1) + F(n-2)</code>.</li> <li>It's easy to calculate recursively, but a naive recursive approach can be very inefficient because it recalculates the same values multiple times.</li> </ul>"},{"location":"dsa/fibonacci/#2-plan","title":"2. Plan:","text":"<ul> <li>The recursive approach is simple but inefficient.</li> <li>Memoization or Tabulation (dynamic programming techniques) can optimize this by storing already computed results.</li> </ul>"},{"location":"dsa/fibonacci/#3-approach","title":"3. Approach:","text":"<ul> <li>First, implement the naive recursive solution.</li> <li>Then, optimize it with memoization (storing results) to avoid recalculating values.</li> </ul>"},{"location":"dsa/fibonacci/#4-code-naive-recursive","title":"4. Code (Naive Recursive):","text":"python<pre><code>def fib(n):\n    if n &lt;= 1:\n        return n\n    return fib(n-1) + fib(n-2)\n</code></pre>"},{"location":"dsa/fibonacci/#5-code-optimized-with-memoization","title":"5. Code (Optimized with Memoization):","text":"python<pre><code>def fib_memo(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n &lt;= 1:\n        return n\n    memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo)\n    return memo[n]\n</code></pre>"},{"location":"dsa/fibonacci/#6-analysis","title":"6. Analysis:","text":"<ul> <li> <p>The naive recursive solution has exponential time complexity <code>O(2^n)</code> because it recalculates the same Fibonacci numbers many times.</p> </li> <li> <p>The memoized solution improves the time complexity to <code>O(n)</code> by storing intermediate results.</p> </li> </ul>"},{"location":"dsa/fibonacci/#conclusion","title":"Conclusion","text":"<p>Understanding how to solve a problem is crucial because it:</p> <ul> <li>Improves efficiency.</li> <li>Helps in adapting solutions to different problems.</li> <li>Teaches you to think critically about algorithms and optimize solutions for better performance.</li> </ul> <p>Just solving problems is important, but developing a strong problem-solving approach makes you not only a better programmer but also a more efficient one, capable of tackling complex problems with ease.</p>"},{"location":"dsa/fibonacci/#javascript","title":"JavaScript","text":"<p>Problem: Find the nth Fibonacci number.</p> <p>The Fibonacci sequence is defined as:</p> <ul> <li>F(0) = 0</li> <li>F(1) = 1</li> <li>F(n) = F(n-1) + F(n-2) for n &gt; 1.</li> </ul>"},{"location":"dsa/fibonacci/#step-by-step-approach-to-solve-the-problem","title":"Step-by-Step Approach to Solve the Problem:","text":""},{"location":"dsa/fibonacci/#step-1-understand-the-problem","title":"Step 1: Understand the Problem","text":"<p>We need to calculate the nth Fibonacci number. The Fibonacci sequence grows exponentially, so the naive recursive solution can be very inefficient for large <code>n</code>. Our goal is to find a solution that efficiently computes the nth Fibonacci number.</p>"},{"location":"dsa/fibonacci/#step-2-naive-recursive-solution","title":"Step 2: Naive Recursive Solution","text":"<p>Let\u2019s start by implementing a simple, naive recursive solution. This is the most straightforward way to approach the problem, but it\u2019s not efficient due to repeated recalculations.</p> javascript<pre><code>function fibonacciNaive(n) {\n  if (n &lt;= 1) {\n    return n; // Base case: return 0 if n = 0 or 1\n  }\n  return fibonacciNaive(n - 1) + fibonacciNaive(n - 2); // Recursive case\n}\n</code></pre> Explanation: <ul> <li> <p>We define the base case for <code>n = 0</code> and <code>n = 1</code>, returning n directly.</p> </li> <li> <p>For other values of <code>n</code>, we recursively call the function with <code>n-1</code> and <code>n-2</code> to calculate the Fibonacci number.</p> </li> </ul> Drawback: <ul> <li>This approach has exponential time complexity (<code>O(2^n)</code>), which means it takes a very long time for larger values of <code>n</code> because the function recalculates the same Fibonacci numbers multiple times.</li> </ul>"},{"location":"dsa/fibonacci/#step-3-optimize-with-memoization","title":"Step 3: Optimize with Memoization","text":"<p>To optimize the above solution, we can use memoization, which stores the results of previously calculated Fibonacci numbers. This reduces the number of recursive calls, making the solution much faster.</p> javascript<pre><code>function fibonacciMemo(n, memo = {}) {\n  if (n in memo) {\n    return memo[n]; // Return the result if it\u2019s already computed\n  }\n  if (n &lt;= 1) {\n    return n; // Base case\n  }\n  // Store the result in memo to avoid redundant calculations\n  memo[n] = fibonacciMemo(n - 1, memo) + fibonacciMemo(n - 2, memo);\n  return memo[n];\n}\n</code></pre> Explanation: <ul> <li>We pass a <code>memo</code> object as an argument that stores the results of previous Fibonacci calculations.</li> <li>If <code>n</code> has already been computed and stored in <code>memo</code>, we return the stored value.</li> <li>If not, we recursively compute the Fibonacci number and store it in <code>memo</code> before returning it.</li> </ul> <p>Time Complexity: <code>O(n)</code></p> <p>This is a significant improvement because we now only calculate each Fibonacci number once.</p>"},{"location":"dsa/fibonacci/#step-4-further-optimization-with-iteration","title":"Step 4: Further Optimization with Iteration","text":"<p>Next, we can optimize the solution even further by using an iterative approach. This approach is generally more memory-efficient since it doesn\u2019t require recursion or storing intermediate results in an object.</p> javascript<pre><code>function fibonacciIterative(n) {\n  if (n &lt;= 1) return n; // Base case\n  let prev2 = 0,\n    prev1 = 1;\n  for (let i = 2; i &lt;= n; i++) {\n    let current = prev1 + prev2; // Fibonacci relationship\n    prev2 = prev1; // Update previous values\n    prev1 = current;\n  }\n  return prev1;\n}\n</code></pre> Explanation: <ul> <li> <p>Instead of using recursion, we initialize two variables (<code>prev1</code> and <code>prev2</code>) to store the two most recent Fibonacci numbers.</p> </li> <li> <p>We then iterate from <code>2</code> to <code>n</code>, updating the previous values and calculating the Fibonacci number iteratively.</p> </li> </ul> <p>Time Complexity: <code>O(n)</code></p> <p>Space Complexity: <code>O(1)</code></p> <p>This is the most optimal solution in terms of both time and space.</p>"},{"location":"dsa/fibonacci/#step-5-test-the-solution","title":"Step 5: Test the Solution","text":"<p>Now that we've implemented the solution, let\u2019s test it with some sample inputs.</p> javascript<pre><code>console.log(fibonacciNaive(10)); // Naive recursive approach\nconsole.log(fibonacciMemo(10)); // Optimized recursive approach with memoization\nconsole.log(fibonacciIterative(10)); // Iterative approach\n</code></pre> Expected Output:<pre><code>55  // Fibonacci of 10\n55\n55\n</code></pre>"},{"location":"dsa/fibonacci/#summary-of-problem-solving-steps","title":"Summary of Problem-Solving Steps:","text":"<ol> <li> <p>Understand the problem: In this case, calculating the nth Fibonacci number.</p> </li> <li> <p>Start with a simple solution: A naive recursive solution works but is inefficient.</p> </li> <li> <p>Optimize the solution: Use memoization to reduce repeated calculations.</p> </li> <li> <p>Iterate for further optimization: Move to an iterative approach for a faster and memory-efficient solution.</p> </li> <li> <p>Test your solution: Ensure correctness with sample inputs and edge cases (e.g., <code>fibonacci(0)</code>, <code>fibonacci(1)</code>).</p> </li> </ol>"},{"location":"dsa/fibonacci/#takeaways-for-problem-solving-in-javascript","title":"Takeaways for Problem-Solving in JavaScript:","text":"<ul> <li> <p>Start simple: Begin by writing the simplest solution (like a brute force or naive approach) to get a clear understanding of the problem.</p> </li> <li> <p>Optimize iteratively: Once you have a working solution, consider ways to optimize it. You can improve time complexity (e.g., using memoization) or space complexity (e.g., using iterative solutions).</p> </li> <li> <p>Use built-in data structures: JavaScript offers powerful data structures (e.g., objects for memoization, arrays for iteration) that can help you optimize your solutions.</p> </li> <li> <p>Practice: The more problems you solve, the more you\u2019ll become proficient at recognizing patterns and applying the right approach efficiently.</p> </li> </ul>"},{"location":"dsa/fibonacci/#next-steps","title":"Next Steps:","text":"<p>Now that you've seen the approach in action, I recommend practicing more problems in a similar fashion:</p> <ul> <li> <p>Start with easy problems and use the same problem-solving methodology (understand, implement, optimize).</p> </li> <li> <p>Gradually move to harder problems like dynamic programming, graph algorithms, and tree traversal.</p> </li> <li> <p>Work on optimizing solutions not just for correctness, but also for performance.</p> </li> </ul>"},{"location":"dsa/fibonacci/#reference","title":"Reference","text":"<ul> <li>Fibonacci Numbers</li> </ul>"},{"location":"dsa/longest-substring/","title":"Longest Substring","text":""},{"location":"dsa/longest-substring/#longest-substring-without-repeating-characters","title":"Longest Substring Without Repeating Characters","text":"<p>Great! Let's go through another problem-solving approach in JavaScript, but this time we'll tackle something a little more complex: Finding the longest substring without repeating characters.</p> <p>Problem: Longest Substring Without Repeating Characters</p> <p>Given a string, find the length of the longest substring without repeating characters.</p> <p>Example 1:</p> <ul> <li>Input: <code>\"abcabcbb\"</code></li> <li>Output: <code>3</code></li> <li>Explanation: The answer is <code>\"abc\"</code>, with the length of 3.</li> </ul> <p>Example 2:</p> <ul> <li>Input: <code>\"bbbbb\"</code></li> <li>Output: <code>1</code></li> <li>Explanation: The answer is <code>\"b\"</code>, with the length of 1.</li> </ul> <p>Example 3:</p> <ul> <li>Input: <code>\"pwwkew\"</code></li> <li>Output: <code>3</code></li> <li>Explanation: The answer is <code>\"wke\"</code>, with the length of 3.</li> </ul>"},{"location":"dsa/longest-substring/#step-1-understand-the-problem","title":"Step 1: Understand the Problem","text":"<p>We need to find the length of the longest substring in a given string that doesn\u2019t have repeating characters.</p> <p>This means that:</p> <ul> <li>We will move through the string character by character.</li> <li>We need to keep track of the characters we\u2019ve seen so far.</li> <li>As soon as we encounter a character that\u2019s been seen before, we\u2019ll stop extending the current substring and try to find a longer one starting from the next position.</li> </ul>"},{"location":"dsa/longest-substring/#step-2-naive-solution","title":"Step 2: Naive Solution","text":"<p>A naive approach would involve checking all possible substrings, but this could lead to an inefficient solution with O(n\u00b2) time complexity because we would generate and check every possible substring.</p> <p>Here\u2019s how a naive approach might look:</p> javascript<pre><code>function lengthOfLongestSubstringNaive(s) {\n  let maxLength = 0;\n\n  // Generate all substrings\n  for (let i = 0; i &lt; s.length; i++) {\n    for (let j = i + 1; j &lt;= s.length; j++) {\n      const substring = s.slice(i, j);\n      const uniqueChars = new Set(substring);\n\n      // If all characters in the substring are unique, update maxLength\n      if (substring.length === uniqueChars.size) {\n        maxLength = Math.max(maxLength, substring.length);\n      }\n    }\n  }\n\n  return maxLength;\n}\n</code></pre> Explanation: <ul> <li>We use two loops to generate every possible substring.</li> <li>For each substring, we check if all characters are unique by using a <code>Set</code>.</li> <li>If the length of the substring matches the size of the set (indicating no duplicates), we update the <code>maxLength</code>.</li> </ul> <p>Time Complexity: <code>O(n\u00b2)</code></p> <p>While this works, it\u2019s not efficient for large strings because we\u2019re generating all substrings and checking uniqueness repeatedly.</p>"},{"location":"dsa/longest-substring/#step-3-optimized-approach-sliding-window","title":"Step 3: Optimized Approach (Sliding Window)","text":"<p>A much better approach is to use the sliding window technique, which allows us to scan the string in a linear pass and keep track of the substring as we go.</p> Sliding Window Technique: <ul> <li>We maintain two pointers (or indices) to represent the current window of the substring.</li> <li>As we move the right pointer to explore new characters, we adjust the left pointer to shrink the window when we encounter a duplicate character.</li> <li>We keep track of the characters using a <code>Set</code> (or <code>Map</code>) and adjust the window size accordingly.</li> </ul> <p>Here\u2019s how the optimized solution looks:</p> <pre><code>function lengthOfLongestSubstring(s) {\n  let charSet = new Set(); // To store unique characters in the current window\n  let left = 0; // Left pointer\n  let maxLength = 0; // To track the maximum length of the substring\n\n  for (let right = 0; right &lt; s.length; right++) {\n    // If the character at the right pointer already exists in the set, shrink the window\n    while (charSet.has(s[right])) {\n      charSet.delete(s[left]); // Remove the character at the left pointer\n      left++; // Move the left pointer to the right\n    }\n\n    // Add the current character to the set\n    charSet.add(s[right]);\n\n    // Update the maxLength if necessary\n    maxLength = Math.max(maxLength, right - left + 1);\n  }\n\n  return maxLength;\n}\n</code></pre> Explanation: <ul> <li> <p>We use a sliding window technique with two pointers (<code>left</code> and <code>right</code>).</p> </li> <li> <p>As we iterate through the string with the <code>right</code> pointer, we check if the current character exists in the <code>Set</code>. If it does, we shrink the window from the <code>left</code> by moving the left pointer until the character at the <code>right</code> pointer can be added to the <code>Set</code> without duplication.</p> </li> <li> <p>After adding the current character, we update the <code>maxLength</code> as we expand the window.</p> </li> </ul> <p>Time Complexity: <code>O(n)</code></p> <ul> <li> <p>We only go through the string once, and each character is added and removed from the set at most once.</p> </li> <li> <p>This is much more efficient than the naive solution, especially for large strings.</p> </li> </ul>"},{"location":"dsa/longest-substring/#step-4-test-the-solution","title":"Step 4: Test the Solution","text":"<p>Let\u2019s test the solution with the examples:</p> javascript<pre><code>console.log(lengthOfLongestSubstring(\"abcabcbb\")); // Output: 3\nconsole.log(lengthOfLongestSubstring(\"bbbbb\")); // Output: 1\nconsole.log(lengthOfLongestSubstring(\"pwwkew\")); // Output: 3\n</code></pre> Expected Output:<pre><code>3\n1\n3\n</code></pre>"},{"location":"dsa/longest-substring/#step-5-analyze-the-approach","title":"Step 5: Analyze the Approach","text":"<p>Time Complexity: <code>O(n)</code></p> <ul> <li>We only iterate over the string once with the <code>right</code> pointer.</li> <li>The <code>left</code> pointer may move from the beginning to the end, but each character is added to and removed from the <code>Set</code> at most once, so the total number of operations is proportional to the length of the string.</li> </ul> <p>Space Complexity: <code>O(k)</code></p> <ul> <li>The space complexity is dependent on the number of unique characters in the string. In the worst case, if all characters are unique, we store all <code>n</code> characters in the <code>Set</code>, so the space complexity is <code>O(n)</code>. But in practice, it could be smaller, depending on the alphabet size.</li> </ul>"},{"location":"dsa/longest-substring/#summary-of-the-problem-solving-approach","title":"Summary of the Problem-Solving Approach:","text":"<ol> <li> <p>Understand the problem: You need to find the longest substring without repeating characters.</p> </li> <li> <p>Start with a naive approach: The brute-force method of generating all substrings works but is inefficient.</p> </li> <li> <p>Optimize the solution: Use the sliding window technique to maintain a dynamic window of unique characters while iterating through the string.</p> </li> <li> <p>Test the solution: Validate it against different test cases.</p> </li> <li> <p>Analyze the complexity: Ensure the solution is efficient in terms of both time and space.</p> </li> </ol>"},{"location":"dsa/longest-substring/#next-steps","title":"Next Steps:","text":"<p>Now that you\u2019ve seen the sliding window approach, I recommend practicing problems that require the sliding window technique. Here are some ideas:</p> <ul> <li>Substring with at most two distinct characters.</li> <li>Longest subarray with sum at most k.</li> <li>Find all anagrams in a string.</li> </ul>"},{"location":"dsa/overview/","title":"Overview","text":""},{"location":"dsa/overview/#overview","title":"Overview","text":"<p>To dive deep into Data Structures and Algorithms (DSA) in 7 days, it's essential to focus on key concepts while maintaining a strong balance between theory and practice. Here's a 7-day roadmap to guide you through the learning process:</p>"},{"location":"dsa/overview/#day-1-introduction-to-dsa-arrays-and-strings","title":"Day 1: Introduction to DSA + Arrays and Strings","text":"<ol> <li> <p>Introduction to DSA:</p> <ul> <li> <p>What are Data Structures and Algorithms?</p> </li> <li> <p>Time and Space Complexity (Big O Notation) \u2013 Understanding the efficiency of algorithms.</p> </li> <li> <p>Different types of problems you might solve with DSA (sorting, searching, dynamic programming, etc.).</p> </li> </ul> </li> <li> <p>Arrays:</p> <ul> <li> <p>Definition and types of arrays.</p> </li> <li> <p>Basic operations: Insertion, deletion, traversal.</p> </li> <li> <p>Multi-dimensional arrays.</p> </li> <li> <p>Common problems:</p> <ul> <li>Finding maximum/minimum.</li> <li>Finding duplicates.</li> <li>Reverse an array.</li> <li>Merge sorted arrays.</li> </ul> </li> </ul> </li> <li> <p>Strings:</p> <ul> <li> <p>String manipulation: Concatenation, substring, length, etc.</p> </li> <li> <p>Common problems:</p> <ul> <li>Palindrome checking.</li> <li>Anagram checking.</li> <li>String reversal.</li> <li>Finding the first non-repeating character.</li> </ul> </li> </ul> </li> <li> <p>Practice:</p> <ul> <li>Solve at least 5-6 problems on arrays and strings (LeetCode, HackerRank).</li> </ul> </li> </ol>"},{"location":"dsa/overview/#day-2-linked-lists","title":"Day 2: Linked Lists","text":"<ol> <li> <p>Introduction to Linked Lists:</p> <ul> <li> <p>Singly linked list vs Doubly linked list.</p> </li> <li> <p>Head, tail, and nodes.</p> </li> <li> <p>Operations: Insertion, deletion, traversal.</p> </li> </ul> </li> <li> <p>Types of Linked Lists:</p> <ul> <li> <p>Singly Linked List.</p> </li> <li> <p>Doubly Linked List.</p> </li> <li> <p>Circular Linked List.</p> </li> </ul> </li> <li> <p>Common Problems:</p> <ul> <li> <p>Reverse a linked list.</p> </li> <li> <p>Detect cycle in a linked list (Floyd\u2019s Cycle-Finding Algorithm).</p> </li> <li> <p>Find the middle element.</p> </li> <li> <p>Merge two sorted linked lists.</p> </li> </ul> </li> <li> <p>Practice:</p> <ul> <li>Solve 5-6 linked list problems (LeetCode, GeeksforGeeks).</li> </ul> </li> </ol>"},{"location":"dsa/overview/#day-3-stacks-and-queues","title":"Day 3: Stacks and Queues","text":"<ol> <li> <p>Stacks:</p> <ul> <li>LIFO (Last In, First Out) structure.</li> <li>Operations: Push, pop, peek, isEmpty.</li> <li>Implementation using arrays and linked lists.</li> </ul> </li> <li> <p>Queues:</p> <ul> <li>FIFO (First In, First Out) structure.</li> <li>Operations: Enqueue, dequeue, peek, isEmpty.</li> <li>Implementation using arrays and linked lists.</li> </ul> </li> <li> <p>Types of Queues:</p> <ul> <li>Simple Queue.</li> <li>Circular Queue.</li> <li>Priority Queue (can be implemented using heaps).</li> </ul> </li> <li> <p>Common Problems:</p> <ul> <li>Parentheses matching (valid parentheses).</li> <li>Implement a stack using two queues.</li> <li>Implement a queue using two stacks.</li> </ul> </li> <li> <p>Practice:</p> <ul> <li>Solve at least 5-6 problems on stacks and queues (LeetCode, HackerRank).</li> </ul> </li> </ol>"},{"location":"dsa/overview/#day-4-recursion-and-divide-and-conquer","title":"Day 4: Recursion and Divide-and-Conquer","text":"<ol> <li> <p>Recursion:</p> <ul> <li>What is recursion?</li> <li>Base case and recursive case.</li> <li>Recursive tree and its importance in solving problems.</li> <li>Backtracking.</li> </ul> </li> <li> <p>Divide-and-Conquer:</p> <ul> <li>Concept of breaking problems into subproblems.</li> <li>Example problems: Merge Sort, Quick Sort.</li> </ul> </li> <li> <p>Common Problems:</p> <ul> <li>Factorial using recursion.</li> <li>Fibonacci series using recursion.</li> <li>Merge Sort and Quick Sort.</li> <li>Binary search (recursive version).</li> <li>Solving problems like the N-Queens problem (Backtracking).</li> </ul> </li> <li> <p>Practice:</p> <ul> <li>Solve 5-6 recursive problems (LeetCode, GeeksforGeeks).</li> </ul> </li> </ol>"},{"location":"dsa/overview/#day-5-trees","title":"Day 5: Trees","text":"<ol> <li> <p>Introduction to Trees:</p> <ul> <li>Tree terminology: Root, Node, Leaf, Depth, Height.</li> <li>Types of trees: Binary Tree, Binary Search Tree (BST), AVL Tree, etc.</li> </ul> </li> <li> <p>Binary Trees:</p> <ul> <li>Pre-order, In-order, Post-order traversal.</li> <li>Tree construction and deletion.</li> <li>Depth-first Search (DFS) and Breadth-first Search (BFS).</li> </ul> </li> <li> <p>Binary Search Trees (BST):</p> <ul> <li>Insertion and deletion in BST.</li> <li>Searching in BST.</li> <li>Finding the minimum and maximum in BST.</li> </ul> </li> <li> <p>Common Problems:</p> <ul> <li>Height of a binary tree.</li> <li>Level order traversal.</li> <li>Checking if a binary tree is a BST.</li> <li>Finding the lowest common ancestor (LCA).</li> <li>Diameter of a binary tree.</li> </ul> </li> <li> <p>Practice:</p> <ul> <li>Solve 5-6 problems on trees (LeetCode, HackerRank).</li> </ul> </li> </ol>"},{"location":"dsa/overview/#day-6-graphs-and-algorithms","title":"Day 6: Graphs and Algorithms","text":"<ol> <li> <p>Introduction to Graphs:</p> <ul> <li>What is a graph? Nodes (vertices), Edges.</li> <li>Types of graphs: Directed, Undirected, Weighted, Unweighted.</li> <li>Representing graphs: Adjacency matrix, adjacency list.</li> </ul> </li> <li> <p>Graph Traversal:</p> <ul> <li>Depth-First Search (DFS).</li> <li>Breadth-First Search (BFS).</li> </ul> </li> <li> <p>Shortest Path Algorithms:</p> <ul> <li>Dijkstra\u2019s Algorithm.</li> <li>Bellman-Ford Algorithm.</li> </ul> </li> <li> <p>Graph Algorithms:</p> <ul> <li>Topological Sorting (for Directed Acyclic Graphs).</li> <li>Finding Strongly Connected Components (Kosaraju\u2019s Algorithm).</li> </ul> </li> <li> <p>Common Problems:</p> <ul> <li>Detecting cycles in a graph.</li> <li>Finding shortest path in an unweighted graph.</li> <li>Finding connected components in an undirected graph.</li> <li>Topological sort.</li> </ul> </li> <li> <p>Practice:</p> <ul> <li>Solve 5-6 graph problems (LeetCode, HackerRank).</li> </ul> </li> </ol>"},{"location":"dsa/overview/#day-7-dynamic-programming-and-practice","title":"Day 7: Dynamic Programming and Practice","text":"<ol> <li> <p>Introduction to Dynamic Programming (DP):</p> <ul> <li>What is DP?</li> <li>Overlapping subproblems and optimal substructure.</li> <li>Memoization and Tabulation.</li> </ul> </li> <li> <p>Common DP Problems:</p> <ul> <li>Fibonacci Series (Optimized version using DP).</li> <li>0/1 Knapsack Problem.</li> <li>Longest Common Subsequence (LCS).</li> <li>Longest Increasing Subsequence (LIS).</li> <li>Coin Change Problem.</li> </ul> </li> <li> <p>Greedy Algorithms vs. DP:</p> <ul> <li>Understand when to use greedy algorithms vs dynamic programming.</li> </ul> </li> <li> <p>Practice:</p> <ul> <li>Solve 5-6 dynamic programming problems (LeetCode, HackerRank).</li> <li>Try to solve a problem without looking at solutions first.</li> </ul> </li> </ol>"},{"location":"dsa/overview/#extra-tips-for-the-7-day-roadmap","title":"Extra Tips for the 7-Day Roadmap:","text":"<ul> <li> <p>Consistency: Even if you're short on time, make sure you practice every day. DSA is best learned through consistent practice.</p> </li> <li> <p>LeetCode, GeeksforGeeks, and HackerRank are great platforms for problem-solving and practicing concepts.</p> </li> <li> <p>Understand the problem before coding: Take time to analyze the problem and think about the solution before jumping into coding.</p> </li> <li> <p>Focus on efficiency: As you progress, try to optimize your solutions by thinking in terms of time and space complexity.</p> </li> </ul> <p>This roadmap is intense but achievable if you're dedicated. Don\u2019t forget to regularly review concepts to ensure you retain everything you\u2019ve learned!</p>"},{"location":"dsa/pattern/","title":"Pattern","text":""},{"location":"dsa/pattern/#pattern","title":"Pattern","text":"<p>is cracking the dsa question if all about reconizing the pattern?</p> <p>Yes, recognizing patterns is absolutely key when it comes to cracking DSA (Data Structures and Algorithms) problems. It\u2019s one of the most important skills that will help you solve problems efficiently. However, there's more to it than just recognizing patterns. Let me break it down further:</p>"},{"location":"dsa/pattern/#why-recognizing-patterns-is-crucial","title":"Why Recognizing Patterns is Crucial:","text":""},{"location":"dsa/pattern/#1-problem-type-identification","title":"1. Problem Type Identification:","text":"<ul> <li> <p>Many DSA problems fall into well-defined categories, such as sorting, searching, dynamic programming, greedy algorithms, graph traversal, and so on. The more you practice, the more you\u2019ll recognize these patterns and understand which algorithmic technique to apply.</p> </li> <li> <p>For example:</p> <ul> <li> <p>If you see a problem involving finding the shortest path, you might think of Dijkstra's algorithm (for weighted graphs) or Breadth-First Search (BFS) (for unweighted graphs).</p> </li> <li> <p>If the problem involves overlapping subproblems, it\u2019s likely a candidate for dynamic programming.</p> </li> <li> <p>If there\u2019s a sorted array and you're asked to find a target, it could be a binary search problem.</p> </li> </ul> </li> </ul>"},{"location":"dsa/pattern/#2-efficiency","title":"2. Efficiency:","text":"<ul> <li>Once you recognize a pattern, you can skip brute-force approaches and directly apply an optimized algorithm. For example, if you're given an array and you're asked to find the longest increasing subsequence, you may recognize that this is a dynamic programming problem, which has an efficient solution compared to a brute force approach.</li> </ul>"},{"location":"dsa/pattern/#3-time-saving","title":"3. Time-Saving:","text":"<ul> <li>Recognizing a pattern allows you to solve problems more quickly because you won\u2019t have to start from scratch each time. You can immediately apply a known technique or algorithm, saving time especially in competitive programming or coding interviews.</li> </ul>"},{"location":"dsa/pattern/#how-to-recognize-patterns-in-dsa","title":"How to Recognize Patterns in DSA:","text":"<p>Here are some common patterns and how you might recognize them:</p>"},{"location":"dsa/pattern/#1-sliding-window","title":"1. Sliding Window:","text":"<ul> <li> <p>Problem Type: Subarrays, substrings, or sequences with constraints.</p> </li> <li> <p>How to Recognize:</p> <ul> <li> <p>The problem involves finding a subarray or substring with some property (e.g., sum, length, distinct elements).</p> </li> <li> <p>The problem has constraints that can be expanded or contracted (e.g., find the longest substring with no repeating characters, maximum sum of a subarray of fixed size).</p> </li> </ul> </li> <li> <p>Example:</p> <ul> <li>Longest substring without repeating characters.</li> <li>Maximum sum subarray of size <code>k</code>.</li> </ul> </li> </ul>"},{"location":"dsa/pattern/#2-two-pointers","title":"2. Two Pointers:","text":"<ul> <li> <p>Problem Type: Searching or sorting problems.</p> </li> <li> <p>How to Recognize:</p> <ul> <li>The problem can be broken down into pairs of items or requires you to examine elements from both ends of an array/list.</li> </ul> </li> <li> <p>Example:</p> <ul> <li>Find pairs of numbers in an array that sum up to a specific value.</li> <li>Reverse a string using two pointers.</li> </ul> </li> </ul>"},{"location":"dsa/pattern/#3-dynamic-programming-dp","title":"3. Dynamic Programming (DP):","text":"<ul> <li> <p>Problem Type: Problems that can be broken down into smaller overlapping subproblems and have an optimal substructure (i.e., solutions to the problem can be built from solutions to smaller subproblems).</p> </li> <li> <p>How to Recognize:</p> <ul> <li> <p>The problem involves making decisions at each step, where each decision affects future choices (e.g., a sequence, pathfinding, partitioning).</p> </li> <li> <p>You need to remember previous results or calculations to avoid recomputing them.</p> </li> </ul> </li> <li> <p>Example:</p> <ul> <li> <p>Fibonacci series (classic DP problem).</p> </li> <li> <p>Longest common subsequence.</p> </li> <li> <p>0/1 Knapsack problem.</p> </li> </ul> </li> </ul>"},{"location":"dsa/pattern/#4-greedy-algorithms","title":"4. Greedy Algorithms:","text":"<ul> <li> <p>Problem Type: Optimization problems where you make locally optimal choices at each step.</p> </li> <li> <p>How to Recognize:</p> <ul> <li> <p>The problem involves making a series of choices that lead to an optimal global solution.</p> </li> <li> <p>Greedy choice property: You can choose the best option at each step without worrying about future consequences.</p> </li> </ul> </li> <li> <p>Example:</p> <ul> <li> <p>Activity selection problem.</p> </li> <li> <p>Fractional Knapsack problem.</p> </li> <li> <p>Huffman coding.</p> </li> </ul> </li> </ul>"},{"location":"dsa/pattern/#5-backtracking","title":"5. Backtracking:","text":"<ul> <li> <p>Problem Type: Problems where you need to try all possibilities and backtrack when a solution doesn't work.</p> </li> <li> <p>How to Recognize:</p> <ul> <li> <p>The problem involves finding all combinations or permutations (e.g., subset generation, permutation generation).</p> </li> <li> <p>You need to explore different options and undo or \"backtrack\" when a path leads to an invalid solution.</p> </li> </ul> </li> <li> <p>Example:</p> <ul> <li> <p>N-Queens problem.</p> </li> <li> <p>Sudoku solver.</p> </li> <li> <p>Combination sum.</p> </li> </ul> </li> </ul>"},{"location":"dsa/pattern/#6-graph-algorithms","title":"6. Graph Algorithms:","text":"<ul> <li> <p>Problem Type: Problems involving nodes and edges.</p> </li> <li> <p>How to Recognize:</p> <ul> <li>The problem is about finding the shortest path, exploring connected components, or finding cycles in a graph.</li> </ul> </li> <li> <p>Example:</p> <ul> <li> <p>Depth-First Search (DFS) or Breadth-First Search (BFS) for traversing graphs.</p> </li> <li> <p>Dijkstra's algorithm for shortest path.</p> </li> </ul> </li> </ul>"},{"location":"dsa/pattern/#7-binary-search","title":"7. Binary Search:","text":"<ul> <li> <p>Problem Type: Searching problems on sorted arrays or when you need to narrow down a search space.</p> </li> <li> <p>How to Recognize:</p> <ul> <li>The problem involves finding a target in a sorted array, or you need to minimize or maximize a certain value that can be tested in some way (like finding the first position of an element).</li> </ul> </li> <li> <p>Example:</p> <ul> <li> <p>Find the position of a target element in a sorted array.</p> </li> <li> <p>Find the minimum number of days to complete all tasks (or jobs).</p> </li> </ul> </li> </ul>"},{"location":"dsa/pattern/#how-to-improve-pattern-recognition","title":"How to Improve Pattern Recognition:","text":"<ol> <li> <p>Practice Regularly:</p> <ul> <li>The more problems you solve, the more patterns you'll recognize. As you encounter the same types of problems repeatedly, you'll begin to intuitively know what type of algorithm or approach to apply.</li> </ul> </li> <li> <p>Learn and Categorize Algorithms:</p> <ul> <li>Take time to learn and understand common algorithms and their use cases (e.g., DFS, BFS, Dijkstra, merge sort, dynamic programming, etc.). Over time, you\u2019ll be able to match a problem to an algorithm more easily.</li> </ul> </li> <li> <p>Break Problems Into Smaller Parts:</p> <ul> <li>If you\u2019re stuck, break the problem down into smaller, more manageable parts. Try to identify subpatterns that might be easier to handle.</li> </ul> </li> <li> <p>Solve Problems Using Different Approaches:</p> <ul> <li>Try solving the same problem using different approaches (e.g., brute force, dynamic programming, greedy). This helps build a deeper understanding and pattern recognition.</li> </ul> </li> <li> <p>Review Solutions:</p> <ul> <li>After solving a problem, review other solutions (especially those that differ from your own). This will expose you to new patterns and approaches.</li> </ul> </li> <li> <p>Understand Problem Constraints:</p> <ul> <li>Recognizing the constraints of a problem (e.g., size of the input, time complexity) will often point you toward the most efficient algorithm. For instance, if the problem involves a large input size, you'll know to avoid brute force and opt for optimized algorithms like binary search or dynamic programming.</li> </ul> </li> </ol>"},{"location":"dsa/pattern/#conclusion","title":"Conclusion:","text":"<p>Recognizing patterns is extremely important when solving DSA problems, but it\u2019s just part of the equation. To become proficient:</p> <ul> <li>Focus on learning different algorithms and data structures.</li> <li>Practice problem-solving techniques.</li> <li>Learn to analyze problems and break them into smaller pieces.</li> <li>Keep practicing until you can quickly recognize which pattern applies to each problem.</li> </ul>"},{"location":"dsa/understanding/","title":"Understanding","text":""},{"location":"dsa/understanding/#understanding","title":"Understanding","text":"<p>Understanding how to solve a problem is far more important than simply arriving at a solution. The core idea behind learning Data Structures and Algorithms (DSA) is not just about coding but also about developing problem-solving skills and understanding the underlying principles that make solutions efficient.</p>"},{"location":"dsa/understanding/#heres-why-problem-solving-techniques-and-understanding-the-approach-are-crucial","title":"Here's why problem-solving techniques and understanding the approach are crucial:","text":""},{"location":"dsa/understanding/#1-developing-problem-solving-skills","title":"1. Developing Problem-Solving Skills:","text":"<ul> <li> <p>Pattern Recognition: Over time, you'll recognize patterns in problems. You'll start to understand when to apply a specific technique (e.g., dynamic programming, divide-and-conquer, greedy algorithms). This recognition helps you think critically about approaching new problems more efficiently.</p> </li> <li> <p>Problem Decomposition: The ability to break a complex problem into smaller, manageable subproblems is essential. Understanding how to break a problem into pieces makes it much easier to solve, especially with techniques like divide-and-conquer or dynamic programming.</p> </li> <li> <p>Debugging &amp; Optimization: If you know why a solution works, you're better equipped to troubleshoot errors and optimize your solution, particularly in competitive programming or real-world applications where performance is critical.</p> </li> </ul>"},{"location":"dsa/understanding/#2-mastering-core-concepts","title":"2. Mastering Core Concepts:","text":"<ul> <li> <p>When you focus on how to solve problems, you develop a deeper understanding of data structures and algorithms. For example:</p> <ul> <li> <p>In a binary search problem, it's crucial to understand why the search space is halved at each step, not just implement the algorithm.</p> </li> <li> <p>For dynamic programming, understanding the concept of overlapping subproblems and optimal substructure is key, rather than just memorizing the steps for a specific problem (like the Fibonacci sequence).</p> </li> </ul> </li> <li> <p>This deeper understanding makes it easier to adapt your knowledge to different problems in the future.</p> </li> </ul>"},{"location":"dsa/understanding/#3-efficiency-and-scalability","title":"3. Efficiency and Scalability:","text":"<ul> <li> <p>Solving a problem efficiently is just as important as solving it. Many algorithms can be written in different ways, and understanding the trade-offs (time complexity, space complexity) of different approaches will help you decide the best solution for a given problem.</p> </li> <li> <p>For example:</p> <ul> <li> <p>The brute force approach might work for small inputs but may be too slow for larger inputs. Understanding this difference and learning how to optimize the brute force approach is crucial.</p> </li> <li> <p>Knowing when to use a greedy approach, when to use dynamic programming, or when a simple recursive solution is efficient will make a significant impact on the performance of your code.</p> </li> </ul> </li> </ul>"},{"location":"dsa/understanding/#4-interview-and-competitive-programming","title":"4. Interview and Competitive Programming:","text":"<ul> <li> <p>In coding interviews and competitive programming, approaching the problem correctly and explaining your thought process is just as important as getting the right answer. Employers and judges are often more interested in how you break down the problem and approach solving it than whether your solution is 100% correct on the first try.</p> </li> <li> <p>Communication skills in explaining your approach also matter! This is why explaining your reasoning step-by-step is a part of the interview process.</p> </li> </ul>"},{"location":"dsa/understanding/#5-applying-algorithms-in-real-world-projects","title":"5. Applying Algorithms in Real-World Projects:","text":"<ul> <li> <p>Real-world applications often require that you understand the trade-offs involved with various algorithms and data structures. Simply solving problems from an algorithm book isn\u2019t enough\u2014you need to know when and why to use certain algorithms in different contexts (e.g., database query optimization, pathfinding in a game, or sorting large datasets).</p> </li> <li> <p>If you're working on a project, understanding algorithmic complexity and data structure design will help you scale the solution effectively.</p> </li> </ul>"},{"location":"dsa/understanding/#the-key-steps-in-problem-solving","title":"The Key Steps in Problem-Solving:","text":"<ol> <li> <p>Understand the Problem: Break down the problem statement. Clarify inputs, outputs, and constraints. Sometimes, the problem seems hard because the requirements are not clearly understood.</p> </li> <li> <p>Plan the Approach: Think about potential ways to solve the problem. This might involve:</p> <ul> <li>Recognizing patterns (is this similar to a previous problem you've solved?).</li> <li>Considering time and space complexity (how can I optimize my solution?).</li> <li>Breaking the problem into smaller pieces.</li> </ul> </li> <li> <p>Choose the Right Algorithm/Data Structure: Select an appropriate approach (e.g., recursive, dynamic programming, greedy, divide-and-conquer) and choose the right data structures (array, stack, queue, linked list, graph, etc.).</p> </li> <li> <p>Write the Code: Once you have a plan, implement it cleanly. Try to write readable, maintainable code, not just a quick hack.</p> </li> <li> <p>Test the Solution: After implementing the code, test it with edge cases, large inputs, and boundary conditions. Debug if necessary.</p> </li> <li> <p>Optimize the Solution: Once you get it working, think about performance. Is there a faster or more memory-efficient way to solve the problem? Optimize the code accordingly.</p> </li> <li> <p>Learn from Mistakes: Analyze what went wrong if you made a mistake or couldn\u2019t come up with the solution initially. Try to understand why your approach didn\u2019t work and what other approaches could work better.</p> </li> </ol>"},{"location":"dsa/understanding/#example-of-solving-a-problem-thoughtfully-fibonacci-example","title":"Example of Solving a Problem Thoughtfully (Fibonacci Example):","text":"<p>Problem: Find the nth Fibonacci number.</p> <ol> <li> <p>Understanding:</p> <ul> <li> <p>Fibonacci numbers follow the recurrence relation: <code>F(n) = F(n-1) + F(n-2)</code>.</p> </li> <li> <p>It's easy to calculate recursively, but a naive recursive approach can be very inefficient because it recalculates the same values multiple times.</p> </li> </ul> </li> <li> <p>Plan:</p> <ul> <li> <p>The recursive approach is simple but inefficient.</p> </li> <li> <p>Memoization or Tabulation (dynamic programming techniques) can optimize this by storing already computed results.</p> </li> </ul> </li> <li> <p>Approach:</p> <ul> <li> <p>First, implement the naive recursive solution.</p> </li> <li> <p>Then, optimize it with memoization (storing results) to avoid recalculating values.</p> </li> </ul> </li> <li> <p>Code (Naive Recursive):</p> python<pre><code>def fib(n):\n    if n &lt;= 1:\n        return n\n    return fib(n-1) + fib(n-2)\n</code></pre> </li> <li> <p>Code (Optimized with Memoization):</p> <pre><code>def fib_memo(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n &lt;= 1:\n        return n\n    memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo)\n    return memo[n]\n</code></pre> </li> <li> <p>Analysis:</p> <ul> <li> <p>The naive recursive solution has exponential time complexity O(2^n) because it recalculates the same Fibonacci numbers many times.</p> </li> <li> <p>The memoized solution improves the time complexity to O(n) by storing intermediate results.</p> </li> </ul> </li> </ol>"},{"location":"dsa/understanding/#conclusion","title":"Conclusion:","text":"<p>Understanding how to solve a problem is crucial because it:</p> <ul> <li>Improves efficiency.</li> <li>Helps in adapting solutions to different problems.</li> <li>Teaches you to think critically about algorithms and optimize solutions for better performance.</li> </ul> <p>Just solving problems is important, but developing a strong problem-solving approach makes you not only a better programmer but also a more efficient one, capable of tackling complex problems with ease.</p>"},{"location":"http/intro/","title":"Intro","text":"<p>intro</p>"},{"location":"http/OpenID/intro/","title":"Intro","text":"<p>OpenID Connect Protocol</p> <p>OpenID Connect (OIDC) is an identity layer built on top of the OAuth 2.0 framework.</p> <p>OpenID vs. OAuth2</p> <p>While <code>OAuth 2.0</code> is about resource access and sharing, <code>OIDC</code> is about user authentication. Its purpose is to give you one login for multiple sites.</p>"},{"location":"http/OpenID/intro/#overview","title":"Overview","text":"<p>OpenID and OAuth are related but distinct protocols used for authentication and authorization. Here's a breakdown of the differences:</p>"},{"location":"http/OpenID/intro/#1-openid","title":"1. OpenID:","text":"<ul> <li>Purpose: OpenID is primarily used for authentication. It allows users to sign in to third-party applications using their existing credentials from a trusted identity provider (like Google, Facebook, etc.).</li> <li>How it works: OpenID lets you use your identity from one site (the OpenID provider) to log in to other sites (relying parties). It verifies that the user is who they claim to be.</li> <li>Example: You can log into a website using your Google account, and the website will know it's you based on your Google identity.</li> <li>Version: The most common version today is OpenID Connect (OIDC), which is built on top of OAuth 2.0 to add authentication features.</li> </ul>"},{"location":"http/OpenID/intro/#2-oauth","title":"2. OAuth:","text":"<ul> <li>Purpose: OAuth is primarily used for authorization. It allows a user to grant a third-party application limited access to their resources without sharing their credentials (like username or password).</li> <li>How it works: OAuth allows users to give permissions to an application to access specific data on their behalf (e.g., accessing a user's Google Calendar without giving the app your Google login credentials). It uses tokens (access tokens and refresh tokens) for this purpose.</li> <li>Example: A third-party app asking for access to your Facebook posts or your Google Calendar without needing to know your password.</li> <li>Version: The most common version today is OAuth 2.0.</li> </ul>"},{"location":"http/OpenID/intro/#key-differences","title":"Key Differences:","text":"<ul> <li>Purpose: OpenID is for authentication (verifying identity), while OAuth is for authorization (granting access to data/resources).</li> <li>Scope: OpenID is about logging in and verifying a user, whereas OAuth is about granting permissions for a third-party app to access your resources without giving them full access to your account.</li> <li>Overlap: OpenID Connect (OIDC) is an extension of OAuth 2.0 that adds authentication capabilities to OAuth, combining both functions into a single protocol.</li> </ul>"},{"location":"http/OpenID/intro/#how-they-work-together","title":"How They Work Together:","text":"<ul> <li>OpenID Connect (OIDC) uses OAuth 2.0 for the authorization process but adds an identity layer for authentication. In other words, OIDC builds on top of OAuth to authenticate a user and provide their identity information (like an ID token).</li> </ul> So, to sum up <ul> <li>OpenID = Authentication.</li> <li>OAuth = Authorization.</li> <li>OIDC = Authentication over OAuth 2.0.</li> </ul>"},{"location":"http/OpenID/intro/#django-setup-for-openid","title":"Django Setup for OpenID","text":"<p>To implement OpenID Connect authentication in Django and Django Rest Framework (DRF), you will typically use a library like django-allauth or mozilla-django-oidc. These libraries simplify the integration of OpenID Connect into your application by handling the communication with an OpenID provider (like Google, Facebook, etc.).</p> <p>Here\u2019s a step-by-step guide for implementing OpenID Connect in Django and DRF using mozilla-django-oidc:</p> <pre><code>pip install django mozilla-django-oidc djangorestframework\n</code></pre> settings.py<pre><code>INSTALLED_APPS = [\n    # Existing apps\n    'django.contrib.sites',  # Required by django-allauth for OpenID\n    'mozilla_django_oidc',    # For OpenID Connect authentication\n    'rest_framework',         # For Django REST framework\n    'rest_framework.authtoken',  # For token-based authentication\n]\n</code></pre> <pre><code># OpenID Connect settings\nOIDC_RP_CLIENT_ID = 'your-client-id'  # Your client ID from the OpenID provider\nOIDC_RP_CLIENT_SECRET = 'your-client-secret'  # Your client secret from the OpenID provider\nOIDC_OP_AUTHORIZATION_ENDPOINT = 'https://provider.example.com/authorize'\nOIDC_OP_TOKEN_ENDPOINT = 'https://provider.example.com/token'\nOIDC_OP_USERINFO_ENDPOINT = 'https://provider.example.com/userinfo'\nOIDC_OP_JWKS_ENDPOINT = 'https://provider.example.com/jwks'  # Optional: JSON Web Key Set for verification\n\n# URL to redirect users to after login\nLOGIN_REDIRECT_URL = '/'\nLOGOUT_REDIRECT_URL = '/'\n\n# Additional Django settings\nSITE_ID = 1  # Set this to your site ID\n</code></pre> <pre><code>from django.urls import path, include\n\nurlpatterns = [\n    path('oidc/', include('mozilla_django_oidc.urls')),  # Include OIDC authentication URLs\n    # Your other URLs\n]\n</code></pre> <p>User Authentication Views</p> <p>By default, mozilla-django-oidc provides views for login, logout, and callback. You don\u2019t need to implement custom views for these; they will be available at:</p> <ul> <li><code>/oidc/login/</code>: Start the OpenID Connect login flow.</li> <li><code>/oidc/callback/</code>: Handle the callback after authentication.</li> <li><code>/oidc/logout/</code>: Log the user out.</li> </ul>"},{"location":"http/OpenID/intro/#react-setup-for-openid","title":"React Setup for OpenID","text":"<pre><code>npm install oidc-client\n</code></pre> oidc-config.js<pre><code>import { UserManager } from \"oidc-client\";\n\nconst oidcConfig = {\n  authority: \"https://your-openid-provider.com\", // The base URL of your OpenID Connect provider\n  client_id: \"your-client-id\", // Your client ID\n  redirect_uri: \"http://localhost:3000/oidc/callback\", // The redirect URL where the OIDC provider will send the user after authentication\n  response_type: \"code\", // Or \"id_token token\" for Implicit Flow\n  scope: \"openid profile email\", // The scopes you need\n  post_logout_redirect_uri: \"http://localhost:3000\", // URL to redirect to after logout\n};\n\nconst userManager = new UserManager(oidcConfig);\n\nexport default userManager;\n</code></pre>"},{"location":"http/OpenID/intro/#reference","title":"Reference","text":"<ul> <li>How to Use React OIDC in Modern Authentication Methods</li> <li>OpenID Connect and OAuth 2.0 Primer</li> <li>OpenId Connect (OIDC) with Angular</li> <li> <p>LogoutRequest has no PostLogoutRedirectUri in it when using React.js app with ... library: stackoverflow</p> </li> <li> <p>Adding OAuth to a .Net Core - React - Redux App with Identity Server 4 and Redux-oidc - Part 1</p> </li> </ul> <p></p>"},{"location":"http/OpenID/oidc-client/","title":"OIDC Client","text":""},{"location":"http/OpenID/oidc-client/#overview","title":"Overview","text":""},{"location":"http/OpenID/oidc-client/#quickstart","title":"QuickStart","text":"<pre><code>$ npm install oidc-react\n</code></pre>"},{"location":"http/OpenID/oidc-client/#usage","title":"Usage","text":"<pre><code>import { AuthProvider } from \"oidc-react\";\n\nconst oidcConfig = {\n  onSignIn: () =&gt; {\n    // Redirect?\n  },\n  authority: \"https://oidc.io/oauth\",\n  clientId: \"this-is-a-client-id\",\n  redirectUri: \"https://my-app.com/\",\n};\n\nconst Routes = () =&gt; (\n  &lt;AuthProvider {...oidcConfig}&gt;\n    &lt;Switch&gt;\n      &lt;Route exact path=\"/\"&gt;\n        &lt;Dashboard /&gt;\n      &lt;/Route&gt;\n      ...\n    &lt;/Switch&gt;\n  &lt;/AuthProvider&gt;\n);\n</code></pre>"},{"location":"http/OpenID/oidc-client/#reference","title":"Reference","text":"<ul> <li>OIDC React</li> <li>How To Implement OIDC Authentication with React Context API and React Router</li> </ul>"},{"location":"http/graphql/graphql-client/","title":"Client","text":""},{"location":"http/graphql/graphql-client/#graphql-clients","title":"GraphQL Clients","text":"<p>As we\u2019ve said numerous times, GraphQL is just a spec. It doesn\u2019t care whether you\u2019re using it with React or Vue or JavaScript or even a browser. GraphQL has opinions about a few specific topics, but beyond that, your architectural decisions are up to you. This has led to the emergence of tools to enforce some choices beyond the spec. Enter GraphQL clients.</p> <p>GraphQL clients have emerged to speed the workflow for developer teams and improve the efficiency and performance of applications. They handle tasks like network requests, data caching, and injecting data into the user interface. There are many GraphQL clients, but the leaders in the space are Relay and Apollo.</p> <p>Relay is Facebook\u2019s client that works with React and React Native. Relay aims to be the connective tissue between React components and the data that is fetched from the GraphQL server. Relay is used by Facebook, GitHub, Twitch, and more.</p> <p>Apollo Client was developed at Meteor Development Group and is a community-driven effort to build more comprehensive tooling around GraphQL. Apollo Client supports all major frontend development platforms and is framework agnostic. Companies, including Airbnb, CNBC, The New York Times, and Ticketmaster use Apollo Client in production.</p> <p>Which client is easier for a beginner to set up and learn quickly</p> <p>Between Relay and Apollo for GraphQL clients, Apollo Client is easier for a beginner to set up and learn quickly. Apollo has a simpler installation process, straightforward integration with React, and more beginner-friendly documentation and community support. Relay is more complex, with a steeper learning curve and more opinionated architecture, making it better suited for advanced or large-scale React projects rather than beginners. Therefore, Apollo is the recommended choice if you want to get started fast and learn GraphQL client development smoothly.</p>"},{"location":"http/graphql/graphql-client/#setup-apollo-client","title":"Setup Apollo Client","text":"<ol> <li> <p>Install dependencies</p> <p>Run this command in your project directory to install Apollo Client and GraphQL:</p> <pre><code>npm install @apollo/client graphql\n</code></pre> </li> <li> <p>Configure Apollo Client</p> <p>Create a new Apollo Client instance by specifying your GraphQL server endpoint (<code>uri</code>) and setting up the cache:</p> <pre><code>import { ApolloClient, InMemoryCache } from \"@apollo/client\";\n\nconst client = new ApolloClient({\n  uri: \"https://your-graphql-endpoint.com/graphql\", // Replace with your GraphQL API URL\n  cache: new InMemoryCache(),\n});\n</code></pre> </li> <li> <p>Connect Apollo Client to React</p> <p>Wrap your root React component with <code>ApolloProvider</code> and pass the client instance. This makes Apollo Client available throughout your app:</p> <pre><code>import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { ApolloProvider } from \"@apollo/client\";\nimport App from \"./App\"; // Your main app component\n\nReactDOM.render(\n  &lt;ApolloProvider client={client}&gt;\n    &lt;App /&gt;\n  &lt;/ApolloProvider&gt;,\n  document.getElementById(\"root\")\n);\n</code></pre> </li> <li> <p>Fetch data with a query</p> <p>Inside your components, use Apollo's <code>useQuery</code> hook to fetch data from your GraphQL API:</p> <pre><code>import { useQuery, gql } from \"@apollo/client\";\n\nconst GET_ITEMS = gql`\n  query GetItems {\n    items {\n      id\n      name\n    }\n  }\n`;\n\nfunction ItemList() {\n  const { loading, error, data } = useQuery(GET_ITEMS);\n\n  if (loading) return &lt;p&gt;Loading...&lt;/p&gt;;\n  if (error) return &lt;p&gt;Error &lt;/p&gt;;\n\n  return (\n    &lt;ul&gt;\n      {data.items.map(({ id, name }) =&gt; (\n        &lt;li key={id}&gt;{name}&lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  );\n}\n</code></pre> </li> </ol> <p>This setup covers the basics: installing Apollo Client, configuring it, connecting it to React, and running your first query. You can then expand with mutations, subscriptions, and advanced caching as needed.</p>"},{"location":"http/graphql/graphql-client/#most-frequent-error-in-react-18","title":"Most frequent Error in React 18","text":"<p>Error: createRoot(...): Target container is not a DOM element.</p> <p>Fix: Ensure the root container element exists (usually <code>id=\"root\"</code>), and initialize React 18 root properly:</p> <pre><code>import { createRoot } from \"react-dom/client\";\nimport { ApolloProvider } from \"@apollo/client\";\nimport client from \"./apolloClient\";\nimport App from \"./App\";\n\nconst container = document.getElementById(\"root\");\nconst root = createRoot(container);\nroot.render(\n  &lt;ApolloProvider client={client}&gt;\n    &lt;App /&gt;\n  &lt;/ApolloProvider&gt;\n);\n</code></pre> <pre><code>// apolloClient.js\nimport { ApolloClient, InMemoryCache } from \"@apollo/client\";\n\nconst client = new ApolloClient({\n  uri: \"https://your-graphql-endpoint.com/graphql\", // Replace with your GraphQL API URL\n  cache: new InMemoryCache(),\n});\n\nexport default client;\n</code></pre>"},{"location":"http/graphql/graphql-client/#reference","title":"Reference","text":"<ul> <li>Learning GraphQL by Eve Porcello and Alex Banks</li> </ul>"},{"location":"http/graphql/overview/","title":"Overview","text":""},{"location":"http/graphql/overview/#overview","title":"Overview","text":""},{"location":"http/graphql/overview/#rest-drawbacks","title":"REST Drawbacks","text":""},{"location":"http/graphql/overview/#overfetching","title":"Overfetching","text":"Note <p>Overfetching happens when the API returns more data than the client actually needs. For example, if you only need a user's name but the API sends the entire user profile including unnecessary fields, this wastes bandwidth, slows down the app, and consumes extra resources.</p> <pre><code>{\n  \"name\": \"Luke Skywalker\",\n  \"height\": \"172\",\n  \"mass\": \"77\",\n  \"hair_color\": \"blond\",\n  \"skin_color\": \"fair\",\n  \"eye_color\": \"blue\",\n  \"birth_year\": \"19BBY\",\n  \"gender\": \"male\",\n  \"homeworld\": \"https://swapi.co/api/planets/1/\",\n  \"films\": [\n    \"https://swapi.co/api/films/2/\",\n    \"https://swapi.co/api/films/6/\",\n    \"https://swapi.co/api/films/3/\",\n    \"https://swapi.co/api/films/1/\",\n    \"https://swapi.co/api/films/7/\"\n  ],\n  \"species\": [\"https://swapi.co/api/species/1/\"],\n  \"vehicles\": [\n    \"https://swapi.co/api/vehicles/14/\",\n    \"https://swapi.co/api/vehicles/30/\"\n  ],\n  \"starships\": [\n    \"https://swapi.co/api/starships/12/\",\n    \"https://swapi.co/api/starships/22/\"\n  ],\n  \"created\": \"2014-12-09T13:50:51.644000Z\",\n  \"edited\": \"2014-12-20T21:17:56.891000Z\",\n  \"url\": \"https://swapi.co/api/people/1/\"\n}\n</code></pre> <p>This is a huge response. The response exceeds our app\u2019s data needs. We just need the information for name, mass, and height:</p> <pre><code>{\n  \"name\": \"Luke Skywalker\",\n  \"height\": \"172\",\n  \"mass\": \"77\"\n}\n</code></pre> <p>This is a clear case of overfetching</p> <p>we\u2019re getting a lot of data back that we don\u2019t need. The client requires three data points, but we\u2019re getting back an object with 16 keys and sending information over the network that is useless.</p>"},{"location":"http/graphql/overview/#underfetching","title":"Underfetching","text":"<p>Our project manager just showed up at our desk and wants to add another feature to the Star Wars app. In addition to name, height, and mass, we now need to display a list of movie titles for all films that Luke Skywalker is in. After we request the data from swapi.co/api/people/1/, we still need to make additional requests for more data.</p> <p>This means we underfetched.</p> Note <p>Underfetching occurs when the API returns too little data, so the client has to make additional requests to get all the information it needs. For example, if you get only user IDs but need usernames too, you must call the API again to fetch the missing data. This increases the number of requests, slows performance, and complicates client-side code.</p> <p>In simple terms:</p> <ul> <li> <p>Overfetching = getting too much unnecessary data in one go.</p> </li> <li> <p>Underfetching = getting too little data and needing multiple calls to complete the info.</p> </li> </ul> <p>Both issues hurt performance and user experience, especially on slow connections or large datasets. Solutions often involve designing APIs that return just the right amount of data per request or using technologies like GraphQL that let clients specify exactly what data they want.</p>"},{"location":"http/graphql/overview/#managing-rest-endpoints","title":"Managing REST Endpoints","text":"<p>Another common complaint about REST APIs is the lack of flexibility. As the needs on the client change, you usually have to create new endpoints, and those endpoints can begin to multiply quickly.</p> <p>Development speed can be slow because setting up new endpoints often means that frontend and backend teams have more planning and communication to do with each other.</p> <p>With GraphQL, the typical architecture involves a single endpoint. The single endpoint can act as a gateway and orchestrate several data sources, but the one endpoint still makes organization of data easier.</p> <p>In this discussion of REST drawbacks, it\u2019s important to note that many organizations use GraphQL and REST together. Setting up a GraphQL endpoint that fetches data from REST endpoints is a perfectly valid way to use GraphQL. It can be a great way to incrementally adopt GraphQL at your organization.</p> HANDLING ERRORS <p>Successful queries return a JSON document that contains a \u201cdata\u201d key. Unsuccessful queries return a JSON document that contains an \u201cerrors\u201d key. The details of what went wrong is passed as JSON data under this key. A JSON response can contain both \u201cdata\u201d and \u201cerrors.\u201d</p>"},{"location":"http/graphql/overview/#graphql-api-tools","title":"GraphQL API Tools","text":"<p>The GraphQL community has produced several open source tools that you can use to interact with GraphQL APIs. These tools allow you to write queries in the GraphQL query language, send those queries to GraphQL endpoints, and inspect the JSON response.</p>"},{"location":"http/graphql/overview/#graphiql","title":"GraphiQL","text":"<p>GraphiQL is the in-browser integrated development environment (IDE) that was created at Facebook to allow you to query and explore a GraphQL API.</p>"},{"location":"http/graphql/overview/#graphql-playground","title":"GraphQL Playground","text":"<p>Another tool for exploring GraphQL APIs is GraphQL Playground. Created by the team at Prisma, GraphQL Playground mirrors the functionality of GraphiQL and adds on a few interesting options. The easiest way to interact with a GraphQL Playground is to check it out in the browser at graphqlbin.com. After you supply an endpoint, you can interact with the data using the Playground.</p> <p>GraphQL Playground has a desktop version that you can install locally using Homebrew:</p> <pre><code>brew cask install graphql-playground\n</code></pre> <p>Or, you can just download it from the website.</p>"},{"location":"http/graphql/overview/#public-graphql-apis","title":"Public GraphQL APIs","text":"<p>One of the best ways to get started with GraphQL is to practice sending queries using a public API. Several companies and organizations provide a GraphiQL interface that you can use to query public data:</p> <ul> <li>SWAPI (the Star Wars API)</li> </ul> <p>This is a Facebook project that is a wrapper around the SWAPI REST API.</p> <ul> <li>GitHub API</li> </ul> <p>One of the largest public GraphQL APIs, the GitHub GraphQL API allows you to send queries and mutations to view and   change your live data on GitHub. You\u2019ll need to sign in with your GitHub account to interact with the data.</p> <ul> <li>Yelp</li> </ul> <p>Yelp maintains a GraphQL API that you can query using GraphiQL. You do need to create a Yelp developer account to interact with the data in the Yelp API.</p> <p>Many additional examples of public GraphQL APIs are available.</p>"},{"location":"http/graphql/overview/#reference","title":"Reference","text":"<ul> <li>Learning GraphQL by Eve Porcello and Alex Banks</li> </ul>"},{"location":"http/jwt/intro/","title":"Intro","text":"<p>jwt decoder</p> <p> </p> <p></p>"},{"location":"http/jwt/intro/#overview","title":"Overview","text":"<p>In JSON Web Tokens (JWT), there are three main parts: Header, Payload, and Signature</p> JWT HeaderJWT PayloadJWT Signature <p>The header typically contains two key pieces of information:</p> <ul> <li><code>alg</code>: The signing algorithm used, such as <code>HS256</code>, <code>RS256</code>, or <code>ES256</code> (e.g., HMAC, RSA, ECDSA).</li> <li><code>typ</code>: (Optional) The type of the token, which is usually <code>JWT</code>.</li> </ul> <pre><code>{\n    \"alg\": \"HS256\",\n    \"typ\": \"JWT\"\n}\n</code></pre> <p>The payload contains the claims, which are the statements about an entity (typically, the user) and additional data. There are three types of claims:</p> <ul> <li> <p>Registered Claims: These are predefined claims with standard meanings, such as:</p> <ul> <li><code>iss</code> (Issuer): Identifies the principal that issued the token.</li> <li><code>sub</code> (Subject): Identifies the principal that is the subject of the token (usually the user).</li> <li><code>aud</code> (Audience): Identifies the recipients that the token is intended for.</li> <li><code>exp</code> (Expiration Time): Defines the expiration time of the token.</li> <li><code>nbf</code> (Not Before): Defines the time before which the token is not valid.</li> <li><code>iat</code> (Issued At): Identifies when the token was issued.</li> </ul> </li> <li> <p>Public Claims: Custom claims that can be defined by anyone. These should be namespaced to avoid collisions.</p> </li> <li> <p>Private Claims: Claims that are agreed upon by the parties using the token, which are not registered or public but are used for specific purposes (e.g., a user\u2019s roles or permissions).</p> </li> </ul> <pre><code>{\n    \"sub\": \"1234567890\",\n    \"name\": \"John Doe\",\n    \"iat\": 1516239022\n}\n</code></pre> <p>The signature is used to verify that the sender of the JWT is who it says it is, and to ensure that the message wasn\u2019t changed along the way. It\u2019s created by taking the encoded header and payload, applying the signing algorithm, and then signing it with a secret key (HMAC) or a private key (RSA or ECDSA).</p> <p>For example, if you are using the HMAC SHA-256 algorithm (<code>HS256</code>), the signature is created like this:</p> <pre><code>HMACSHA256(\nbase64UrlEncode(header) + \".\" + base64UrlEncode(payload),\nsecret)\n</code></pre>"},{"location":"http/jwt/intro/#types-of-jwt-based-on-usage","title":"Types of JWT Based on Usage:","text":"<p>JWTs can be categorized by their intended use:</p> <ul> <li> <p>Access Tokens: These tokens are used to grant access to a resource (e.g., an API). They often have an expiration time and are usually short-lived.</p> </li> <li> <p>Refresh Tokens: These tokens are used to obtain a new access token after the original access token expires. They are typically long-lived and stored securely.</p> </li> <li> <p>ID Tokens: These are tokens used in OpenID Connect (OIDC) authentication. They contain information about the authenticated user (e.g., user profile information) and are typically used in identity verification.</p> </li> </ul>"},{"location":"http/jwt/intro/#types-of-jwt-based-on-algorithm","title":"Types of JWT Based on Algorithm:","text":"<p>JWTs also differ based on the algorithm used for signing. Some common algorithms include:</p> <ul> <li>HS256 (HMAC with SHA-256): Symmetric signing algorithm where the same secret key is used to both sign and verify the token.</li> <li>RS256 (RSA with SHA-256): Asymmetric signing algorithm using a public/private key pair.</li> <li>ES256 (ECDSA with SHA-256): Asymmetric signing algorithm using Elliptic Curve Digital Signature Algorithm.</li> </ul>"},{"location":"http/jwt/intro/#summary","title":"Summary:","text":"<p>While there are not strictly defined \"types\" of JWTs, you can think of different JWTs based on:</p> <ul> <li>Structure: Header, Payload, and Signature.</li> <li>Usage: Access Token, Refresh Token, ID Token.</li> <li>Signing Algorithms: HS256, RS256, ES256, etc.</li> </ul> <p>These are the most common ways JWTs are categorized or described.</p>"},{"location":"http/jwt/intro/#reference","title":"Reference","text":"<ul> <li>JWT Authentication : Refresh token and Access token</li> <li>What Are Refresh Tokens and How to Use Them Securel</li> <li>What Is the Lifetime of Okta Minted JSON Web Tokens(JWT)</li> <li>Significance of a JWT Refresh Token</li> </ul>"},{"location":"http/jwt/theory/","title":"Theory","text":""},{"location":"http/jwt/theory/#overview","title":"Overview","text":"<p>The theory behind access tokens and refresh tokens lies in the concept of stateless authentication and secure authorization. They are used to manage user sessions in modern web applications, ensuring that users can access resources securely without having to continuously log in.</p>"},{"location":"http/jwt/theory/#access-token","title":"Access Token","text":"<p>An access token is a short-lived credential that allows a user to access specific resources or APIs. It's issued by an authorization server after the user successfully logs in and is usually sent along with API requests to authenticate the user.</p> Characteristics of Access Tokens <ul> <li>Short-lived: Typically has a lifespan of a few minutes to an hour.</li> <li>Bearer token: It\u2019s used as a \"bearer\" token, meaning anyone with the token can access the associated resources.</li> <li>Contains user information: It often contains a claim (payload) about the user, such as user ID, roles, permissions, etc.</li> <li>Stateless: The server doesn't need to maintain a session since the token itself contains the required information.</li> </ul>"},{"location":"http/jwt/theory/#refresh-token","title":"Refresh Token","text":"<p>A refresh token is a long-lived credential used to obtain a new access token when the original access token expires. Refresh tokens are used to maintain a user\u2019s session without requiring them to log in again.</p> Characteristics of Refresh Tokens <ul> <li>Long-lived: Can last days, weeks, or even longer, depending on the configuration.</li> <li>Stored securely: Unlike access tokens, refresh tokens are stored more securely (e.g., in an HTTP-only cookie or encrypted storage).</li> <li>Not used for direct access: It is not sent to access resources directly; instead, it is used to request a new access token from the authorization server.</li> </ul>"},{"location":"http/jwt/theory/#patterns-for-token-refresh","title":"Patterns for token refresh","text":"<p>Below are common patterns used for token refresh in real-time applications:</p>"},{"location":"http/jwt/theory/#1-refresh-after-expiry-reactive-refresh","title":"1. Refresh After Expiry (Reactive Refresh)","text":"<p>How it works:</p> <ul> <li>The client attempts to use the access token for an API or real-time event.</li> <li>If the server responds with <code>401 Unauthorized</code> (indicating the token has expired), the client uses the refresh token to obtain a new access token.</li> <li>Once the new access token is retrieved, the original request is retried.</li> </ul> <p>Use cases:</p> <ul> <li>Suitable for applications with infrequent API calls or real-time events.</li> </ul> <p>Advantages:</p> <ul> <li>Minimal overhead; refreshes only when needed.</li> </ul> <p>Challenges:</p> <ul> <li>Slight delay due to the need to retry the request after obtaining a new token.</li> </ul>"},{"location":"http/jwt/theory/#2-proactive-token-refresh","title":"2. Proactive Token Refresh","text":"<p>How it works:</p> <ul> <li>The client tracks the expiration time of the access token (e.g., from the <code>exp</code> field in a JWT).</li> <li>Before the token expires (e.g., a few seconds or minutes prior), the client requests a new access token using the refresh token.</li> <li>The client seamlessly switches to the new token before making any API or real-time requests.</li> </ul> <p>Use cases:</p> <ul> <li>Applications with high-frequency API calls or real-time interactions.</li> </ul> <p>Advantages:</p> <ul> <li>Prevents disruptions or delays due to token expiration.</li> </ul> <p>Challenges:</p> <ul> <li>Adds complexity as the client needs to manage timers for token refresh.</li> </ul>"},{"location":"http/jwt/theory/#choosing-the-right-pattern","title":"Choosing the Right Pattern","text":"<p>The choice of pattern depends on the specific requirements of the real-time application:</p> Requirement Recommended Pattern High security Token rotation, proactive refresh Low latency Proactive refresh, hybrid pattern WebSocket-based communication Background refresh, embedded refresh Simple implementation Refresh after expiry <p>Each pattern comes with trade-offs, so it\u2019s essential to evaluate based on security, user experience, and the application\u2019s architecture.</p>"},{"location":"http/jwt/theory/#most-used-pattern","title":"Most used Pattern","text":"<p>In web applications, the \"Refresh After Expiry (Reactive Refresh)\" and \"Proactive Token Refresh\" patterns are the most commonly used. The choice between these patterns depends on the application's requirements and architecture:</p>"},{"location":"http/jwt/theory/#1-refresh-after-expiry-reactive-refresh_1","title":"1. Refresh After Expiry (Reactive Refresh)","text":"<p>Why it\u2019s common:</p> <ul> <li>Simpler to implement.</li> <li>Aligns with REST API standards where a <code>401 Unauthorized</code> response signals the client to refresh the token.</li> <li>Efficient in terms of server and client resource usage since tokens are only refreshed when needed.</li> </ul> <p>Common use cases:</p> <ul> <li>Single-page applications (SPAs) like e-commerce platforms, dashboards, and social networks.</li> <li>Applications with moderate or low-frequency API calls.</li> </ul>"},{"location":"http/jwt/theory/#2-proactive-token-refresh_1","title":"2. Proactive Token Refresh","text":"<p>Why it\u2019s common:</p> <ul> <li>Provides a smoother user experience by reducing the chance of users encountering a <code>401 Unauthorized</code> response.</li> <li>Useful in applications with frequent API calls, where token expiry could interrupt user interactions.</li> <li>Works well in real-time or high-frequency use cases.</li> </ul> <p>Common use cases:</p> <ul> <li>Collaborative tools (e.g., Google Docs, Figma).</li> <li>Applications with real-time updates or dashboards that make frequent requests.</li> <li>Systems requiring persistent user sessions without noticeable disruptions.</li> </ul>"},{"location":"http/jwt/theory/#other-patterns-usage","title":"Other Patterns Usage","text":"<p>Token Rotation:</p> <ul> <li>Common in applications with high-security requirements, such as financial systems or sensitive enterprise applications.</li> </ul> <p>Background Refresh (WebSocket):</p> <ul> <li>Popular in real-time applications relying on WebSockets (e.g., chat apps, trading platforms).</li> </ul> <p>Refresh on Reconnect:</p> <ul> <li>Often used in real-time WebSocket applications where connections might frequently drop and reconnect.</li> </ul> <p>Hybrid Pattern:</p> <ul> <li>Adopted by large-scale applications aiming for a balance between user experience and resource efficiency.</li> </ul>"},{"location":"http/jwt/theory/#general-trends","title":"General Trends","text":"<ul> <li>Most web applications start with \"Refresh After Expiry\" for simplicity and evolve to \"Proactive Token Refresh\" or hybrid patterns as they scale or require more seamless user experiences.</li> <li>Proactive refresh is becoming more common in SPAs and real-time applications to prevent disruptions.</li> </ul>"},{"location":"http/jwt/refreshToken/intro/","title":"Refresh Token","text":"axiosBaseQuery.js<pre><code>import axiosInstance from \"./axiosInstance\";\nimport { store } from \"@shared/store/store\";\nimport { updateRefreshToken } from \"@features/auth/services/authSlice\";\nimport logger from \"@shared/utils/logger\";\n\nconst axiosBaseQuery =\n  ({ baseUrl } = { baseUrl: \"\" }) =&gt;\n  async ({ url, method, data, params }, api, extraOptions) =&gt; {\n    try {\n      const result = await axiosInstance.test({\n        url: baseUrl + url,\n        method,\n        data,\n        params,\n      });\n      return { data: result.data };\n    } catch (axiosError) {\n      // const err = axiosError.response?.data || axiosError.message;\n      // return { error: { status: axiosError.response?.status, data: err } };\n      if (axiosError.response?.status === 401) {\n        const refreshToken = store.getState().auth.refresh;\n\n        const refreshResult = await axiosInstance.loginTest({\n          url: baseUrl + \"/auth/refresh\", // Adjust to your refresh token endpoint\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          data: { refreshToken },\n        });\n\n        if (refreshResult?.data) {\n          // Dispatch tokenReceived action with the new token\n          // api.dispatch(tokenReceived(refreshResult.data)); // Ensure correct token structure\n\n          const resultData = refreshResult?.data;\n          logger.info({ msg: \"refreshResult?.data: \", resultData });\n          api.dispatch(updateRefreshToken(refreshResult.data)); // Assuming `refresh` is part of the response\n\n          // // Retry the original request with the new token\n          // const retryResult = await axiosInstance({\n          //   url: baseUrl + url,\n          //   method,\n          //   data,\n          //   params,\n          //   headers: {\n          //     Authorization: `Bearer ${refreshResult.data.token}`, // Adjust token header if needed\n          //   },\n          // });\n\n          return { data: refreshResult.data };\n        } else {\n          // If the refresh fails, dispatch loggedOut action\n          // api.dispatch(loggedOut());\n          // return {\n          //   error: {\n          //     status: 401,\n          //     data: \"Unable to refresh token. Logged out.\",\n          //   },\n          // };\n          logger.info({ msg: \"Unable to refresh token. Logged out.\" });\n        }\n      }\n      // Return error if it's not a 401\n    }\n  };\n\nexport default axiosBaseQuery;\n</code></pre>"},{"location":"interview/draft/","title":"draft","text":""},{"location":"interview/draft/#abstract-models","title":"Abstract models","text":"<p>In Django models, when you define a class attribute Meta with <code>abstract = True</code>, you're essentially creating an abstract base class. This means that the model class itself won't be created in the database, but it serves as a blueprint for other models to inherit from.</p> <p>Here's what each part does:</p> <ul> <li> <p>Meta:</p> <p>This is a class inside a Django model that holds metadata about the model. Metadata includes things like database table name, ordering options, unique constraints, etc.</p> </li> <li> <p>abstract = True:</p> <p>When you set abstract to True within the Meta class, you're telling Django that this model is just a base class for other models. It won't create its own database table. Instead, when a subclass inherits from this abstract model, Django combines the fields from both the abstract model and the subclass into a single database table.</p> </li> </ul> models.py<pre><code>from django.db import models\n\nclass BaseModel(models.Model):\n    name = models.CharField(max_length=100)\n\n    class Meta:\n        abstract = True\n\nclass MyModel(BaseModel):\n    description = models.TextField()\n\n# Django combines the fields from BaseModel and MyModel into a single table\n# named myapp_mymodel\n</code></pre> <p>In this example, <code>BaseModel</code> is an abstract base class with the attribute <code>abstract = True</code>, so it won't create its own table. <code>MyModel</code> inherits from <code>BaseModel</code>, and Django combines the fields from both into a single table named <code>myapp_mymodel</code> in the database.</p>"},{"location":"interview/draft/#explained-in-simple","title":"Explained in Simple","text":"<p>Of course! Imagine you're building a house. You start with a blueprint, right? That blueprint tells the builders how to construct the house, but it's not an actual house itself.</p> <p>In Django models, setting <code>abstract = True</code> is like saying, \"Hey, this is just a blueprint, don't build a house based on it directly.\" Instead, other models can use this blueprint to build their own houses.</p> <p>So, when you create a model with <code>abstract = True</code>, you're making a blueprint for other models to inherit from. Those other models will combine the blueprint's instructions with their own to create a final house (or database table, in Django's case).</p>"},{"location":"interview/draft/#example","title":"Example","text":"models.py<pre><code>from django.db import models\n\nclass PostBase(models.Model):\n    title = models.CharField(max_length=100)\n    content = models.TextField()\n    created_at = models.DateTimeField(auto_now_add=True)\n\n    class Meta:\n        abstract = True\n\nclass BlogPost(PostBase):\n    author = models.CharField(max_length=50)\n\nclass NewsArticle(PostBase):\n    source = models.CharField(max_length=50)\n\n# Now you can create instances of BlogPost and NewsArticle,\n# and Django will automatically create one table for each,\n# combining the fields from PostBase and the subclass.\n</code></pre> <p>In this example:</p> <ul> <li> <p>We define an abstract base class <code>PostBase</code> with common fields like <code>title</code>, <code>content</code>, and <code>created_at</code>. We set <code>abstract = True</code> in its Meta class to indicate that it's just a blueprint.</p> </li> <li> <p>We create two concrete subclasses of <code>PostBase</code>: <code>BlogPost</code> and <code>NewsArticle</code>. Each of these adds its own specific field (<code>author</code> for <code>BlogPost</code> and <code>source</code> for <code>NewsArticle</code>).</p> </li> <li> <p>When you create instances of <code>BlogPost</code> and <code>NewsArticle</code>, Django combines the fields from <code>PostBase</code> and the subclass into separate database tables, creating a single table for each subclass (<code>BlogPost</code> and <code>NewsArticle</code>).</p> </li> </ul>"},{"location":"interview/intro/","title":"Intro","text":"Django Concepts Error Handling and Testing model inheritance"},{"location":"interview/intro/#key-django-programming-concepts","title":"Key Django Programming Concepts","text":"<ol> <li> <p>MTV (Model-Template-View) Architecture</p> <ul> <li> <p>Model: The model is the definitive source of information about your data. It contains the essential fields and behaviors of the data you\u2019re storing. Django follows the DRY Principle (Don't Repeat Yourself), so the model defines the data structure once and automatically derives things from it.</p> </li> <li> <p>Template: Django\u2019s template layer provides a designer-friendly syntax for rendering the information to be presented to the user. It allows for a separation of presentation and business logic, which is beneficial for both developers and designers.</p> </li> <li> <p>View: Views are responsible for processing user requests and returning responses. Views access the data through models and delegate the formatting of the output to the templates. In Django, a view can be a simple function or a class-based view.</p> </li> </ul> </li> <li> <p>ORM (Object-Relational Mapping)</p> <p>Django's ORM allows for the definition of data models in Python, which are then automatically translated into database tables. This abstraction layer lets you interact with your database using high-level Python code instead of SQL, making database operations safer and more intuitive.</p> </li> <li> <p>Migrations</p> <p>Migrations are Django's way of allowing database schema changes (such as adding a field, deleting a model, etc.) without requiring SQL. Migrations are Python files that describe these changes in code, allowing them to be versioned and shared with other developers.</p> </li> <li> <p>Admin Interface</p> <p>Django automatically generates a professional, production-ready admin interface for manipulating website data. This interface is dynamically created from the model definitions and provides a rapid development workflow for managing content.</p> </li> <li> <p>URLs and URLconf</p> <p>Django lets you design URLs however you want, with no framework limitations. The URLconf maps URL patterns (described as regular expressions) to your view functions. This modular URL handling system allows for a clean URL scheme and SEO-friendly web applications.</p> </li> <li> <p>Templates and Template Tags</p> <p>Templates are HTML files that allow Python-like expressions for inserting dynamic content. Template tags are Django\u2019s way of adding functionality to templates, such as looping through lists, loading static files, or applying filters to variables.</p> </li> <li> <p>Forms and ModelForms</p> <p>Django\u2019s forms handle the task of rendering HTML forms and processing submitted data. ModelForms simplify the process by creating form fields automatically for the corresponding model, making it easier to create forms for data entry without repetitive code.</p> </li> <li> <p>Authentication and Authorization</p> <p>Django comes with a built-in authentication system that handles user authentication, sessions, permissions, and user groups. It provides a way to associate users with content and to build permissions and authorization checks into your application.</p> </li> <li> <p>Middleware</p> <p>Middleware are layers of logic that Django executes during request and response processing. They're used for session management, user authentication, cross-site request forgery protection, content compression, and more.</p> </li> <li> <p>Signals</p> <p>Signals allow certain pieces of code to be notified when actions occur elsewhere in the application. They are especially useful for decoupling apps and making them extensible.</p> </li> <li> <p>Testing</p> <p>Django's built-in test framework allows for writing unit tests that ensure your application's code behaves as expected. It includes a test client for simulating requests and responses, allowing for comprehensive testing of views and interaction flows.</p> </li> <li> <p>Security Features</p> <p>Django includes numerous security features that are enabled by default, protecting against SQL Injection, Cross-site Scripting (XSS), Cross-Site Request Forgery (CSRF), and more. Django's security practices are constantly updated to address new vulnerabilities.</p> </li> <li> <p>RESTful APIs with Django REST Framework</p> <p>While Django can handle creating simple APIs using its views and serializers, Django REST Framework (DRF) provides a more flexible toolkit for building web APIs, offering features like authentication policies, serialization, and customizable endpoints.</p> </li> <li> <p>Asynchronous Support</p> <p>Starting with Django 3.1, the framework introduced support for asynchronous views, middleware, and tests, allowing developers to write async code for performance improvements in I/O-bound and high-latency operations.</p> </li> <li> <p>Deployment</p> <p>Deploying a Django application involves more than just transferring code to a server. It includes setting up a web server like Apache or Nginx, configuring a WSGI server like Gunicorn, handling static and media files, and setting up a database.</p> </li> </ol> <p>Understanding these concepts in detail can significantly enhance your ability to develop, deploy, and maintain web applications with Django, leveraging its full potential to create robust, scalable, and secure web solutions.</p>"},{"location":"interview/intro/#error-handling-and-testing","title":"Error Handling and Testing","text":"<ol> <li> <p>Exceptions</p> <p>Error handling is an essential aspect of writing reliable and robust Python programs. Python uses exceptions to handle errors and other exceptional events. An exception is an error that happens during the execution of a program. Exceptions are caught using try and except blocks.</p> <ul> <li> <p>try Block:</p> <p>You place the code that might throw an exception within a try block.</p> </li> <li> <p>except Block:</p> <p>If an exception occurs, the code inside the except block is executed. Multiple except blocks can catch different types of exceptions.</p> </li> <li> <p>else and finally:</p> <p>The else block can be used to execute code when the try block raises no exceptions, and the finally block lets you execute code, regardless of the result of the try and except blocks.</p> </li> </ul> </li> <li> <p>Assertions</p> <p>Assertions are a systematic way to check that the internal state of a program is as expected. An assertion is a sanity-check that you can turn on or turn off when you have finished testing the program. An expression is tested, and if the result comes up false, an exception is raised. Assertions are carried out through the assert statement.</p> </li> <li> <p>Unit Testing</p> <p>Python includes several modules for designing and running tests, called unit tests. Unit testing ensures that your code behaves as expected. The unittest framework, inspired by Java's JUnit, provides features for test automation, sharing of setup and shutdown code, aggregation of tests into collections, and independence of the tests from the reporting framework.</p> </li> </ol>"},{"location":"interview/intro/#using-model-inheritance","title":"Using model inheritance","text":"<p>Django supports model inheritance. It works in a similar way to standard class inheritance in Python. Django offers the following three options to use model inheritance:</p> <ul> <li>Abstract models: Useful when you want to put some common information into several models.</li> <li>Multi-table model inheritance: Applicable when each model in the hierarchy is considered a complete model by itself.</li> <li>Proxy models: Useful when you need to change the behavior of a model, for example, by including additional methods, changing the default manager, or using different meta options.</li> </ul>"},{"location":"interview/intro/#questions","title":"Questions","text":"can we use djangorestframework standalone without using django? <p>No, Django REST Framework (DRF) is tightly coupled with the Django web framework and cannot be used standalone without Django. Here are the key reasons why DRF depends on Django:</p> <ol> <li> <p>Integration with Django's Request-Response Cycle: DRF extends Django's capabilities to easily build RESTful APIs by providing serializers, views, and authentication mechanisms that integrate seamlessly with Django's request-response cycle.</p> </li> <li> <p>Dependency on Django's ORM: DRF relies on Django's ORM (Object-Relational Mapping) for database operations. Serializers in DRF are designed to work with Django models, making it easy to serialize and deserialize data between Django models and JSON or other formats.</p> </li> <li> <p>URL Routing and Views: DRF uses Django's URL routing system (urls.py) and views (views.py) to define API endpoints and handle HTTP requests. This tight integration simplifies the process of defining API routes and mapping them to view functions or class-based views.</p> </li> <li> <p>Authentication and Permissions: DRF leverages Django's authentication and permissions system to secure API endpoints. It provides ready-to-use authentication classes and permission classes that work seamlessly with Django's user authentication system.</p> </li> <li> <p>Admin Interface: DRF integrates with Django's admin interface, allowing you to manage and view API data similarly to how you manage Django models in the admin panel.</p> </li> <li> <p>Django Middleware: DRF can utilize Django middleware for additional request/response handling, logging, or other cross-cutting concerns.</p> </li> </ol> <p>Alternatives</p> <p>If you're looking to build RESTful APIs without using Django, you might consider using lightweight frameworks or libraries specifically designed for API development in Python, such as:</p> <ul> <li> <p>FastAPI: A modern, fast (high-performance), web framework for building APIs with Python 3.7+ based on standard Python type hints.</p> </li> <li> <p>Flask: A micro web framework for Python based on Werkzeug, Jinja 2, and good intentions. Flask is lightweight and flexible, making it suitable for building APIs.</p> </li> <li> <p>Falcon: A high-performance Python framework for building cloud APIs and web app backends. It's designed for speed and efficiency.</p> </li> </ul> <p>These frameworks provide alternatives to Django and can be used to develop APIs standalone without the dependency on Django's architecture and ORM. Each has its own strengths and weaknesses, so the choice depends on your specific requirements and preferences for building APIs.</p>"},{"location":"interview/intro/#reference","title":"Reference","text":"<ul> <li>PYTHON FOR WEB Development: DJANGO &amp; FLASK UNCHAINED by Hayden Van Der Post Vincent Bisette</li> <li>Django 4 By Example Fourth Edition by Antonio Mel\u00e9 : 524</li> </ul>"},{"location":"interview/core/function-signature/","title":"function signature","text":"<p>In programming languages, a function signature refers to the part of the function definition that specifies the function's name, its parameters, and, in some languages, its return type. The function signature provides essential information about how the function can be called and what arguments are required. It serves as a contract or blueprint for what the function will accept and return.</p>"},{"location":"interview/core/function-signature/#components-of-a-function-signature","title":"Components of a Function Signature","text":"<ul> <li>Function Name: The identifier by which the function is called.</li> <li>Parameters: The list of input variables (or arguments) that the function accepts. This includes the number and types of parameters.</li> <li>Return Type <code>(in some languages)</code>: Specifies the type of value the function returns.</li> </ul> PythonJavaScriptJavaC++TypeScript python<pre><code>def add(a: int, b: int) -&gt; int:\n    return a + b\n</code></pre> <ul> <li>Function Name: <code>add</code></li> <li>Parameters: <code>a</code> and <code>b</code> of type <code>int</code></li> <li>Return Type: <code>int</code></li> </ul> javascript<pre><code>function multiply(x, y) {\n    return x * y;\n}\n</code></pre> <ul> <li>Function Name: <code>multiply</code></li> <li>Parameters: <code>x</code> and <code>y</code> (types are not explicitly declared in JavaScript, though you can use TypeScript for type annotations)</li> <li>Return Type: Not explicitly declared (implicitly returns a number)</li> </ul> java<pre><code>public int subtract(int x, int y) {\n    return x - y;\n}\n</code></pre> <ul> <li>Function Name: <code>subtract</code></li> <li>Parameters: <code>x</code> and <code>y</code> of type <code>int</code></li> <li>Return Type: <code>int</code></li> </ul> cpp<pre><code>int divide(int numerator, int denominator) {\n    return numerator / denominator;\n}\n</code></pre> <ul> <li>Function Name: <code>divide</code></li> <li>Parameters: <code>numerator</code> and <code>denominator</code> of type <code>int</code></li> <li>Return Type: <code>int</code></li> </ul> typescript<pre><code>function concatenate(a: string, b: string): string {\n    return a + b;\n}\n</code></pre> <ul> <li>Function Name: <code>concatenate</code></li> <li>Parameters: <code>a</code> and <code>b</code> of type <code>string</code></li> <li>Return Type: <code>string</code></li> </ul>"},{"location":"interview/core/function-signature/#significance-of-function-signatures","title":"Significance of Function Signatures","text":"<ol> <li> <p>Code Clarity: Function signatures help make code clearer by specifying what types of inputs are expected and what the function will return.</p> </li> <li> <p>Type Checking: In statically typed languages, the function signature helps with type checking, ensuring that functions are called with the correct types of arguments.</p> </li> <li> <p>Documentation: Function signatures serve as a form of documentation for other developers to understand how to use the function properly.</p> </li> <li> <p>Overloading: In languages that support function overloading (e.g., Java, C++), the function signature allows multiple functions with the same name but different parameters.</p> </li> </ol> <p>In summary, the function signature is a fundamental aspect of function definitions that conveys the interface of the function, allowing for correct usage and integration within a program.</p>"},{"location":"interview/core/function-signature/#returning-a-value","title":"returning a value","text":"<p>In programming, returning a value from a function is often necessary to produce a result that other parts of your code can use. However, not every function needs to return a value. The decision to return a value or not depends on the function's purpose and the specific requirements of your program.</p> <ol> <li> <p>Functions That Return a Value</p> <p>Functions that are designed to produce a result or compute a value usually include a return statement. The return value can be used by the caller of the function for further processing.</p> Example in Python:<pre><code>def add(a: int, b: int) -&gt; int:\n    return a + b\n\nresult = add(5, 3)  # result is now 8\n</code></pre> Example in JavaScript:<pre><code>function multiply(x, y) {\n    return x * y;\n}\n\nlet result = multiply(4, 5);  // result is now 20\n</code></pre> </li> <li> <p>Functions That Do Not Return a Value</p> <p>Functions that perform actions rather than calculations or data transformations might not need to return a value. These functions often perform operations like printing to the console, modifying global state, or interacting with external systems.</p> Example in Python (No Return Value):<pre><code>def print_message(message: str):\n    print(message)\n\nprint_message(\"Hello, World!\")  # Prints \"Hello, World!\" to the console\n</code></pre> Example in JavaScript (No Return Value):<pre><code>function logMessage(message) {\n    console.log(message);\n}\n\nlogMessage(\"Hello, World!\");  // Logs \"Hello, World!\" to the console\n</code></pre> </li> </ol> What Happens If a Function Does Not Return a Value? <ul> <li> <p>Default Return Value: In languages like <code>Python</code> and <code>JavaScript</code>, if a function does not explicitly return a value, it returns a default value:</p> <ul> <li>Python: The default return value is <code>None</code>.</li> <li>JavaScript: The default return value is <code>undefined</code>.</li> </ul> Python Example:<pre><code>def no_return():\n    pass\n\nresult = no_return()  # result is None\n</code></pre> JavaScript Example:<pre><code>function noReturn() {\n    // no return statement\n}\n\nlet result = noReturn();  // result is undefined\n</code></pre> </li> <li> <p>Utility: Functions that do not return a value are useful for performing side effects:</p> <ul> <li>Logging: Writing information to the console or a log file.</li> <li>Modifying State: Changing global variables or updating class properties.</li> <li>Interacting with External Systems: Sending data to a server or writing to a file.</li> </ul> </li> <li> <p>Control Flow: Some functions control the flow of execution without returning a value, such as functions that raise exceptions or terminate a program.</p> Python Example:<pre><code>def terminate_program():\n    raise SystemExit(\"Terminating program.\")\n</code></pre> JavaScript Example:<pre><code>function terminateProgram() {\n    throw new Error(\"Terminating program.\");\n}\n</code></pre> </li> </ul> <p>Summary</p> <ul> <li> <p>Functions That Return Values: Used when the result of a computation or data transformation needs to be used later in the code.</p> </li> <li> <p>Functions That Do Not Return Values: Used when the function performs an action or produces a side effect, such as logging or modifying state.</p> </li> </ul> <p>Whether or not to use a <code>return</code> statement depends on the function's purpose and how it fits into the overall design of your program. Functions without return values can still be valuable for their side effects and control flow capabilities.</p>"},{"location":"interview/core/function-signature/#languages-that-return-default-values","title":"Languages That Return Default Values","text":"<p>In programming, whether a function returns a default value when no explicit return statement is provided depends on the language. Here's a breakdown of some popular programming languages and their behavior regarding default return values:</p> Languages That Return Default Values <ol> <li> <p>Python</p> <ul> <li>Default Return Value: <code>None</code></li> <li>Reason: In Python, if a function does not have an explicit <code>return</code> statement, it implicitly returns <code>None</code>. This design simplifies function definitions by ensuring that all functions return a value, making it easier to handle cases where a function might not need to return a value but still maintains a consistent interface.</li> </ul> python<pre><code>def do_nothing():\n    pass\n\nresult = do_nothing()  # result is None\n</code></pre> </li> <li> <p>JavaScript</p> <ul> <li>Default Return Value: <code>undefined</code></li> <li>Reason: In JavaScript, if a function does not have an explicit <code>return</code> statement, it implicitly returns <code>undefined</code>. This behavior aligns with JavaScript's loose typing and dynamic nature, where <code>undefined</code> is used to represent an uninitialized or non-existent value.</li> </ul> javascrip<pre><code>function doNothing() {\n    // no return statement\n}\n\nlet result = doNothing();  // result is undefined\n</code></pre> </li> </ol> Languages Where Default Return Values Are Not Applicable <ol> <li> <p>C++</p> <ul> <li>Default Return Value: Undefined behavior if the return type is not <code>void</code></li> <li>Reason: In C++, if a function that is supposed to return a value (i.e., not of type <code>void</code>) does not have a return statement, it leads to undefined behavior. This is because C++ expects an explicit return value for non-<code>void</code> functions to maintain well-defined program behavior.</li> </ul> cpp<pre><code>int add(int a, int b) {\n    // no return statement\n}\n\nint result = add(1, 2);  // Undefined behavior\n</code></pre> </li> <li> <p>Java</p> <ul> <li>Default Return Value: None (Functions must explicitly return a value)</li> <li>Reason: In Java, methods with non-<code>void</code> return types must include an explicit <code>return</code> statement. The language enforces this rule to ensure that methods conform to their declared return types and avoid potential runtime errors.</li> </ul> java<pre><code>public int add(int a, int b) {\n    return a + b;\n}\n\nint result = add(1, 2);  // result is 3\n</code></pre> </li> </ol> <p>Why Default Return Values Are Used</p> <ol> <li> <p>Language Design Philosophy: Default return values often reflect the language's design philosophy and goals. For example, Python and JavaScript favor flexibility and simplicity, while languages like Swift and Java emphasize explicitness and type safety.</p> </li> <li> <p>Error Handling: Providing default return values can help prevent errors related to uninitialized values. In dynamically typed languages like Python and JavaScript, <code>None</code> and <code>undefined</code> serve as indicators of missing or uninitialized values.</p> </li> <li> <p>Conciseness: Languages like Ruby use implicit returns to enable more concise and readable code, reducing boilerplate and making it easier to write expressive functions.</p> </li> <li> <p>Safety and Clarity: Languages like Swift and Java require explicit return values to ensure that function contracts are clear and enforced, reducing the risk of unexpected behavior and improving code safety.</p> </li> </ol> <p>Summary</p> <ul> <li>Languages with Default Values: Python (<code>None</code>), JavaScript (<code>undefined</code>), Ruby (last evaluated expression)</li> <li>Languages without Default Values: Swift, C++, Java (require explicit return values for non-void functions)</li> </ul> <p>The behavior of default return values reflects the language's design goals, such as simplicity, safety, and expressiveness.</p>"},{"location":"interview/core/memonic/","title":"Memonic","text":"<p>memonic</p>"},{"location":"interview/core/serialization-versus-deserialization/","title":"Serialization","text":"<p>An object is something that lives in the application memory. We can invoke its method or access its attributes in our application. </p> <p>However, when we want to transfer or store an object, we will have to convert it into a storable or transferrable format, and that format will be a stream of bytes. It can then be stored in a text file, in a database, or be transmitted over the internet. </p> <p>The process of converting an object to a stream of bytes is called serialization. This stream of bytes persists the state of the object so that it can be recreated later. The recreation of the object from a stream of bytes is called deserialization.</p>"},{"location":"interview/core/serialization-versus-deserialization/#reference","title":"Reference","text":"<ul> <li>Python API Development Fundamentals - pg 126</li> </ul>"},{"location":"interview/core/theory/","title":"Theory","text":"<p>There are three main categories of cloud computing services out there.</p> <ol> <li>Software as a Service (SaaS)</li> <li>Platform as a Service (PaaS)</li> <li>Infrastructure as a Service (IaaS)</li> </ol> Microservices <p>DEFINITION</p> <p>A microservice is an architectural style in which components of a system are designed as independently deployable services. Microservices are designed around well-defined business subdomains, and they talk to each other using lightweight protocols, such as HTTP.</p> <p>DEFINITION</p> <p>A monolith is an architectural pattern in which the whole application is deployed as a single build.</p> <ul> <li></li> </ul>"},{"location":"interview/core/theory/#marshalling-vs-serilization","title":"Marshalling vs Serilization","text":"<p>Marshalling and serialization are related concepts in Django, but they are not exactly the same. Both involve converting data from one format to another, but they are used in slightly different contexts and with different purposes.</p>"},{"location":"interview/core/theory/#serialization","title":"Serialization","text":"<p>Serialization in Django refers to the process of converting complex data types, such as Django model instances, into a format that can be easily rendered into JSON, XML, or other content types. This is particularly useful for API development, where data needs to be sent over the network in a standard format.</p> <p>In Django, serialization is often achieved using the serializers module from the Django REST framework (DRF). Here's a basic example of how serialization works in Django:</p> <pre><code>from rest_framework import serializers\nfrom myapp.models import MyModel\n\nclass MyModelSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = MyModel\n        fields = '__all__'\n</code></pre> <p>This serializer can then be used to convert MyModel` instances to and from JSON, XML, or other formats.</p>"},{"location":"interview/core/theory/#marshalling","title":"Marshalling","text":"<p>Marshalling is a broader term that refers to the process of transforming data structures or objects into a format that can be stored or transmitted and later reconstructed. While marshalling is a general concept used in many programming languages and frameworks, in the context of Django, it can be seen as part of the serialization process, especially when dealing with data transmission over networks.</p> <p>In the Django REST framework, marshalling is effectively handled by the serializers, as they not only serialize data into specific formats but also ensure the data is in a suitable structure for transmission and storage.</p>"},{"location":"interview/core/theory/#differences","title":"Differences","text":"<ul> <li>Scope: Serialization is specifically about converting objects to a different format (like JSON or XML). Marshalling, on the other hand, is a broader concept that includes serialization but also involves preparing data for transmission and ensuring it can be correctly reconstructed.</li> <li>Context: In Django, serialization is the more commonly used term and is often associated with the Django REST framework and APIs. Marshalling is more of a general concept in computer science that encompasses serialization.</li> </ul> <ul> <li>Marshalling: wikipedia</li> </ul>"},{"location":"interview/leetcode/intro/","title":"Intro","text":"<p>leetcode</p>"},{"location":"interview/why-question/control-statement-detail/","title":"Control Statement Detail","text":""},{"location":"interview/why-question/control-statement-detail/#why","title":"Why","text":"<p>Understanding when to use <code>if...else</code> versus <code>switch</code> statements depends largely on the specifics of the problem you're solving and the nature of the conditions you need to handle. Here's a deeper dive into each:</p>"},{"location":"interview/why-question/control-statement-detail/#ifelse-statement","title":"<code>if...else</code> Statement","text":"<p>When to Use:</p> <ol> <li> <p>Complex Conditions:</p> <p>Use <code>if...else</code> when the conditions you're evaluating are complex or not easily expressed with discrete values. For example, if you need to compare a variable to ranges or perform complex logical operations, <code>if...else</code> is more flexible.</p> <pre><code>if (age &lt; 13) {\n    // Child\n} else if (age &gt;= 13 &amp;&amp; age &lt; 20) {\n    // Teenager\n} else {\n    // Adult\n}\n</code></pre> </li> <li> <p>Multiple Conditions:</p> <p>When you have multiple conditions that don\u2019t fall into a simple pattern or are based on different variables.</p> <pre><code>if (temperature &gt; 30 &amp;&amp; humidity &gt; 70) {\n    // Hot and humid\n} else if (temperature &gt; 30) {\n    // Hot but not humid\n} else if (humidity &gt; 70) {\n    // Humid but not hot\n} else {\n    // Neither hot nor humid\n}\n</code></pre> </li> <li> <p>Non-Discrete Values:</p> <p>When you need to compare a variable against a condition that is not just a single value, such as ranges or complex expressions.</p> <pre><code>if (score &gt;= 90) {\n    // A\n} else if (score &gt;= 80) {\n    // B\n} else if (score &gt;= 70) {\n    // C\n} else {\n    // F\n}\n</code></pre> </li> </ol> <p>Advantages:</p> <ul> <li>Flexibility: Handles a broader range of conditions.</li> <li>Complex Expressions: Allows for complex logical expressions and comparisons.</li> </ul> <p>Disadvantages:</p> <ul> <li>Readability: Can become less readable with many conditions or complex logic.</li> </ul>"},{"location":"interview/why-question/control-statement-detail/#switch-statement","title":"<code>switch</code> Statement","text":"<p>When to Use:</p> <ol> <li> <p>Discrete Values:</p> <p>Use <code>switch</code> when you are comparing a variable to a fixed set of discrete values (like enums or constants). It's particularly useful when the variable is of integral types (like integers or enumerated values) and you have a limited number of cases to handle.</p> <pre><code>switch (day) {\n    case 1:\n        // Monday\n        break;\n    case 2:\n        // Tuesday\n        break;\n    case 3:\n        // Wednesday\n        break;\n    // ...\n    default:\n        // Default case\n}\n</code></pre> </li> <li> <p>Clarity with Many Cases:</p> <p>When you have many discrete conditions that would otherwise require a long series of <code>if...else</code> statements, <code>switch</code> can improve readability and organization.</p> <pre><code>switch (userRole) {\n    case \"admin\":\n        // Admin functionality\n        break;\n    case \"user\":\n        // User functionality\n        break;\n    case \"guest\":\n        // Guest functionality\n        break;\n    default:\n        // Default functionality\n}\n</code></pre> </li> <li> <p>Performance:</p> <p>In some cases, especially with large numbers of cases, switch statements can be more performant than <code>if...else</code> chains because some compilers optimize them using jump tables or hash tables.</p> </li> </ol> <p>Advantages:</p> <ul> <li>Readability: Cleaner and more organized when handling many discrete values.</li> <li>Performance: Potentially optimized for performance by compilers or interpreters.</li> </ul> <p>Disadvantages:</p> <ul> <li>Limited Flexibility: Typically only suitable for discrete values; more complex conditions are difficult to handle.</li> <li>Limited Types: In many languages, <code>switch</code> statements are restricted to integers, enums, or specific types.</li> </ul>"},{"location":"interview/why-question/control-statement-detail/#summary","title":"Summary","text":"<ul> <li>Use <code>if...else</code> for complex conditions, ranges, and when you need flexibility with logical expressions.</li> <li>Use <code>switch</code> when you have a variable with a discrete set of values and want a clear, organized way to handle multiple specific cases.</li> </ul> <p>In many modern languages, <code>switch</code> statements have evolved to handle more complex scenarios (like pattern matching in newer versions of languages like Java and C#), but <code>if...else</code> remains the go-to for more intricate decision-making.</p>"},{"location":"interview/why-question/control-statement-detail/#depth","title":"Depth","text":"<p>Detailed Analysis of if...else vs. switch</p>"},{"location":"interview/why-question/control-statement-detail/#ifelse-statement_1","title":"<code>if...else</code> Statement","text":"<p>When to Use:</p> <p>Complex Conditions and Logical Operations:</p> <ul> <li> <p><code>if...else</code> is ideal for situations where conditions are not simply a match against discrete values but involve more complex logic. This includes comparisons, logical operations, or combinations of different variables.</p> </li> <li> <p>Example:</p> <pre><code>if (temperature &gt; 30 &amp;&amp; humidity &gt; 70) {\n    // Handle hot and humid conditions\n} else if (temperature &gt; 30) {\n    // Handle only hot conditions\n} else if (humidity &gt; 70) {\n    // Handle only humid conditions\n} else {\n    // Handle other conditions\n}\n</code></pre> </li> </ul> <p>Non-Discrete Conditions:</p> <ul> <li> <p>Use <code>if...else</code> when conditions involve ranges or intervals. <code>switch</code> is typically less suited for this kind of logic.</p> </li> <li> <p>Example:</p> <pre><code>if (score &gt;= 90) {\n    // Grade A\n} else if (score &gt;= 80) {\n    // Grade B\n} else if (score &gt;= 70) {\n    // Grade C\n} else {\n    // Grade F\n}\n</code></pre> </li> </ul> <p>Boolean Logic and Multiple Variables:</p> <ul> <li> <p>When decisions depend on multiple variables or complex boolean expressions, <code>if...else</code> provides the flexibility to handle these conditions.</p> </li> <li> <p>Example:</p> <pre><code>if (isWeekend &amp;&amp; !isHoliday) {\n    // Weekend but not a holiday\n} else if (isWeekend &amp;&amp; isHoliday) {\n    // Weekend and a holiday\n} else {\n    // Not a weekend\n}\n</code></pre> </li> </ul> <p>Advantages:</p> <ul> <li>Flexibility: Handles complex conditions and logical operations.</li> <li>Readability: Suitable for situations where the logic is intricate and cannot be expressed as discrete values.</li> </ul> <p>Disadvantages:</p> <ul> <li>Verbosity: For a large number of discrete cases, <code>if...else</code> can become verbose and harder to manage.</li> </ul>"},{"location":"interview/why-question/control-statement-detail/#switch-statement_1","title":"<code>switch</code> Statement","text":"<p>When to Use:</p> <p>Discrete Values and Enumerations:</p> <ul> <li> <p>Use <code>switch</code> when you need to select one of many predefined discrete values (such as enums or constants) based on the value of a single variable.</p> </li> <li> <p>Example:</p> <pre><code>switch (day) {\n    case 1:\n        // Monday\n        break;\n    case 2:\n        // Tuesday\n        break;\n    case 3:\n        // Wednesday\n        break;\n    // Additional cases\n    default:\n        // Default case for unmatched values\n}\n</code></pre> </li> </ul> <p>Improved Readability with Multiple Cases:</p> <ul> <li> <p><code>switch</code> enhances readability and maintainability when dealing with multiple discrete values. It organizes the logic more clearly compared to multiple <code>if...else</code> statements.</p> </li> <li> <p>Example:</p> <pre><code>switch (statusCode) {\n    case 200:\n        // OK\n        break;\n    case 404:\n        // Not Found\n        break;\n    case 500:\n        // Internal Server Error\n        break;\n    default:\n        // Handle other status codes\n}\n</code></pre> </li> </ul> <p>Potential Performance Benefits:</p> <ul> <li>In some cases, <code>switch</code> statements can be optimized by the compiler to use jump tables or hash tables, leading to performance improvements over a series of <code>if...else</code> statements. This is more noticeable with a large number of cases.</li> </ul> <p>Advantages:</p> <ul> <li>Clarity: Provides a clear and organized structure for handling multiple discrete cases.</li> <li>Performance: Can be optimized for performance in some scenarios with many cases.</li> </ul> <p>Disadvantages:</p> <ul> <li>Limited Flexibility: Typically only handles discrete values and is less suited for complex logical conditions.</li> <li>Language Limitations: In some languages, <code>switch</code> statements have limitations regarding the types of values they can handle (e.g., they might not support strings or complex types directly).</li> </ul>"},{"location":"interview/why-question/control-statement-detail/#language-documentation-and-guidelines","title":"Language Documentation and Guidelines","text":"<p>Programming languages often define the behavior and limitations of if...else and switch statements in their documentation, but the specifics can vary. Here\u2019s how you might find guidance in language documentation:</p> <ul> <li>Syntax and Examples: Documentation usually provides the syntax and examples of <code>if...else</code> and <code>switch</code> statements.</li> <li>Best Practices: Many languages have best practices and performance considerations related to these constructs. For example, documentation may suggest using <code>switch</code> for a large number of discrete cases due to performance reasons.</li> <li>Language-Specific Limitations: Documentation may also highlight language-specific constraints or enhancements. For example, newer versions of languages might extend the capabilities of <code>switch</code> (like pattern matching in recent versions of Python and Java).</li> </ul>"},{"location":"interview/why-question/control-statement-detail/#practical-considerations","title":"Practical Considerations","text":"<p>When choosing between <code>if...else</code> and <code>switch</code>, consider the following practical aspects:</p> <ol> <li> <p>Number of Conditions:</p> <ul> <li>Use <code>switch</code> for a large number of discrete cases for better readability.</li> <li>Use <code>if...else</code> for fewer cases or more complex conditions.</li> </ul> </li> <li> <p>Condition Complexity:</p> <ul> <li>Use <code>if...else</code> for conditions involving ranges, intervals, or logical combinations.</li> <li>Use <code>switch</code> for straightforward, discrete value comparisons.</li> </ul> </li> <li> <p>Maintainability:</p> <ul> <li>Consider which construct will be easier to maintain and understand, especially as the codebase grows.</li> </ul> </li> </ol> <p>In summary, while <code>if...else</code> provides flexibility and is suitable for complex or non-discrete conditions, <code>switch</code> offers clarity and potential performance benefits for discrete value comparisons. The choice between them often depends on the nature of the conditions and the specific requirements of the problem at hand.</p>"},{"location":"interview/why-question/control-statement-detail/#discrete-non-discrete-values","title":"Discrete &amp; Non-Discrete Values","text":"<p>Understanding \"discrete values\" and \"enumerations\" versus \"non-discrete\" values is crucial for choosing the right control flow construct in programming. Let\u2019s delve into these concepts:</p>"},{"location":"interview/why-question/control-statement-detail/#discrete-values","title":"Discrete Values","text":"<p>Discrete values refer to distinct, separate values that are clearly defined and typically belong to a finite set. These values are usually distinct and separate from each other, making them ideal for use with constructs like <code>switch</code> statements.</p> <p>Characteristics:</p> <ul> <li>Finite Set: Discrete values come from a limited and defined set of possible values.</li> <li>Distinct: Each value is unique and separate from the others.</li> <li>Integral Types: Often, discrete values are integers or enumerated types (enums).</li> </ul> <p>Examples:</p> <ul> <li> <p>Integer Constants: Values like <code>1</code>, <code>2</code>, <code>3</code>, etc.</p> <pre><code>switch (dayOfWeek) {\n    case 1: // Monday\n    case 2: // Tuesday\n    case 3: // Wednesday\n    // ...\n    default: // Handle unexpected values\n}\n</code></pre> </li> <li> <p>Enumerations: Named constants that represent a set of related values.</p> <pre><code>enum Day {\n    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY\n}\n\nDay today = Day.MONDAY;\n\nswitch (today) {\n    case MONDAY:\n        // Handle Monday\n        break;\n    case TUESDAY:\n        // Handle Tuesday\n        break;\n    // Other cases\n}\n</code></pre> </li> <li> <p>String Literals: In some languages, <code>switch</code> can handle string literals if the language supports it.</p> <pre><code>switch (color) {\n    case \"red\":\n        // Handle red\n        break;\n    case \"green\":\n        // Handle green\n        break;\n    case \"blue\":\n        // Handle blue\n        break;\n    default:\n        // Handle other colors\n}\n</code></pre> </li> </ul>"},{"location":"interview/why-question/control-statement-detail/#non-discrete-values","title":"Non-Discrete Values","text":"<p>Non-discrete values refer to values that do not come from a finite or well-defined set. These values are often more complex, continuous, or range-based, making them less suitable for constructs like <code>switch</code> and better suited for <code>if...else statements</code>.</p> <p>Characteristics:</p> <ul> <li>Continuous or Range-Based: Non-discrete values can be continuous (e.g., floating-point numbers) or represent a range of values.</li> <li>Complex Conditions: They often require more complex conditions or comparisons, which are better handled by <code>if...else</code>.</li> </ul> <p>Examples:</p> <ul> <li> <p>Ranges: Values that fall within a certain range, such as ages, temperatures, etc.</p> <pre><code>if (temperature &lt; 0):\n    # Handle freezing conditions\nelse if (temperature &gt;= 0 &amp;&amp; temperature &lt;= 30):\n    # Handle cold to moderate conditions\nelse:\n    # Handle hot conditions\n</code></pre> </li> <li> <p>Complex Conditions: Situations involving logical combinations or relationships between multiple variables.</p> <pre><code>if (age &lt; 13) {\n    // Child\n} else if (age &gt;= 13 &amp;&amp; age &lt; 20) {\n    // Teenager\n} else if (age &gt;= 20 &amp;&amp; age &lt; 60) {\n    // Adult\n} else {\n    // Senior\n}\n</code></pre> </li> </ul>"},{"location":"interview/why-question/control-statement-detail/#summary_1","title":"Summary","text":"<p>Discrete Values:</p> <ul> <li>Come from a finite set of distinct, separate values.</li> <li>Ideal for <code>switch</code> statements due to their clear boundaries and discrete nature.</li> <li>Examples: specific integers, enumerations, named constants.</li> </ul> <p>Non-Discrete Values:</p> <ul> <li>May involve ranges, intervals, or more complex conditions.</li> <li>Better suited for <code>if...else</code> statements, which can handle a wider range of logical conditions.</li> <li>Examples: ranges of numbers, conditions involving multiple variables.</li> </ul> <p>Choosing between <code>if...else</code> and <code>switch</code> often depends on whether your conditions involve discrete, clearly defined values or more complex, continuous conditions.</p>"},{"location":"interview/why-question/control-statement-detail/#example","title":"Example","text":"<p>Sure, let\u2019s go through examples of both discrete and non-discrete values in different programming contexts to illustrate their use:</p>"},{"location":"interview/why-question/control-statement-detail/#discrete-values_1","title":"Discrete Values","text":"<p>Discrete values are distinct, separate, and finite values. They are ideal for switch statements or similar constructs where each value is clearly defined and separate from the others.</p> Example 1Example 2 <p>Integer Constants (Switch Statement)</p> <p>Imagine a scenario where you need to handle different days of the week:</p> <pre><code>int dayOfWeek = 3; // Assume 1 = Monday, 2 = Tuesday, etc.\n\nswitch (dayOfWeek) {\n    case 1:\n        System.out.println(\"Monday\");\n        break;\n    case 2:\n        System.out.println(\"Tuesday\");\n        break;\n    case 3:\n        System.out.println(\"Wednesday\");\n        break;\n    case 4:\n        System.out.println(\"Thursday\");\n        break;\n    case 5:\n        System.out.println(\"Friday\");\n        break;\n    case 6:\n        System.out.println(\"Saturday\");\n        break;\n    case 7:\n        System.out.println(\"Sunday\");\n        break;\n    default:\n        System.out.println(\"Invalid day\");\n}\n</code></pre> <p>Here, <code>dayOfWeek</code> is a discrete value from a finite set of integers, making it suitable for a <code>switch</code> statement.</p> <p>Enumerations (Switch Statement)</p> <p>Consider an <code>enum</code> representing different types of user roles:</p> <pre><code>enum UserRole {\n    ADMIN, USER, GUEST\n}\n\nUserRole role = UserRole.ADMIN;\n\nswitch (role) {\n    case ADMIN:\n        System.out.println(\"Admin role\");\n        break;\n    case USER:\n        System.out.println(\"User role\");\n        break;\n    case GUEST:\n        System.out.println(\"Guest role\");\n        break;\n    default:\n        System.out.println(\"Unknown role\");\n}\n</code></pre> <p>In this example, <code>UserRole</code> is an enumeration with a finite set of named constants, making it ideal for a <code>switch</code> statement.</p>"},{"location":"interview/why-question/control-statement-detail/#non-discrete-values_1","title":"Non-Discrete Values","text":"<p>Non-discrete values can be ranges, continuous values, or involve complex conditions that don\u2019t fit neatly into a finite set. These are better handled with <code>if...else</code> statements.</p> Example 1Example 2 <p>Range of Values (If-Else Statement)</p> <p>Consider a scenario where you need to classify ages into different categories:</p> <pre><code>age = 25\n\nif age &lt; 13:\n    print(\"Child\")\nelif 13 &lt;= age &lt; 20:\n    print(\"Teenager\")\nelif 20 &lt;= age &lt; 60:\n    print(\"Adult\")\nelse:\n    print(\"Senior\")\n</code></pre> <p>Here, <code>age</code> is a non-discrete value because it falls into a range of categories. This requires <code>if...else</code> to handle the different age ranges.</p> <p>Complex Conditions (If-Else Statement)</p> <p>Imagine you need to make decisions based on a combination of temperature and humidity:</p> <pre><code>let temperature = 85; // in Fahrenheit\nlet humidity = 75; // in percentage\n\nif (temperature &gt; 80 &amp;&amp; humidity &gt; 70) {\n    console.log(\"Hot and humid\");\n} else if (temperature &gt; 80) {\n    console.log(\"Hot but not humid\");\n} else if (humidity &gt; 70) {\n    console.log(\"Humid but not hot\");\n} else {\n    console.log(\"Mild conditions\");\n}\n</code></pre> <p>In this case, <code>temperature</code> and <code>humidity</code> are non-discrete values because they involve ranges and combinations, making <code>if...else</code> a better fit.</p>"},{"location":"interview/why-question/control-statement-detail/#summary_2","title":"Summary","text":"<ul> <li>Discrete Values: Clear, distinct, and finite. Suitable for <code>switch</code> statements. Examples include integers representing days of the week or enumerations.</li> <li>Non-Discrete Values: Involve ranges, intervals, or complex conditions. Suitable for <code>if...else</code> statements. Examples include age ranges or conditions based on multiple variables.</li> </ul> <p>Understanding whether your values are discrete or non-discrete helps you choose the most appropriate control flow construct for clarity and efficiency.</p>"},{"location":"interview/why-question/control-statement/","title":"Control Statement","text":""},{"location":"interview/why-question/control-statement/#overview","title":"Overview","text":"<p>Most programming languages have a common set of control statements that help manage the flow of a program. The most fundamental ones are:</p> <ol> <li> <p>Conditional Statements:</p> <p>These allow a program to make decisions and execute different code based on conditions. The most common conditional statements are:</p> <ul> <li><code>if</code>: Executes a block of code if its condition is true.</li> <li><code>else</code>: Executes a block of code if the preceding <code>if</code> condition is false.</li> <li><code>else if</code>: Tests additional conditions if the previous conditions are false.</li> <li><code>switch</code>: Chooses one of many code blocks to execute based on the value of an expression.</li> </ul> </li> <li> <p>Looping Statements:</p> <p>These execute a block of code multiple times based on certain conditions. Common looping statements include:</p> <ul> <li><code>for</code>: Repeats a block of code a specific number of times.</li> <li><code>while</code>: Repeats a block of code as long as a condition remains true.</li> <li><code>do...while</code>: Similar to <code>while</code>, but it guarantees that the block of code will be executed at least once before the condition is tested.</li> </ul> </li> <li> <p>Jump Statements: These alter the flow of control in a program.</p> <ul> <li><code>break</code>: Exits from the nearest loop or switch statement.</li> <li><code>continue</code>: Skips the rest of the current iteration in a loop and proceeds with the next iteration.</li> <li><code>return</code>: Exits from the current function and optionally returns a value.</li> </ul> </li> <li> <p>Exception Handling (in some languages):</p> <p>Manages errors and exceptional situations that occur during runtime.</p> <ul> <li><code>try...catch</code>: Attempts to execute a block of code and handles exceptions if they occur.</li> <li><code>finally</code>: Executes code after the <code>try</code> and `catch`` blocks, regardless of whether an exception was thrown.</li> </ul> </li> </ol> <p>These statements are foundational and present in varying forms across different programming languages, though their exact syntax and additional features may differ.</p>"},{"location":"interview/why-question/intro/","title":"Intro","text":"<p>intro</p>"},{"location":"interview/why-question/try-catch/","title":"try catch","text":""},{"location":"interview/why-question/try-catch/#what-is-try-catch","title":"What is Try-Catch?","text":"<p>In programming, try-catch is a construct used to handle exceptions or errors that may occur during the execution of a program. It allows you to separate normal code from error-handling code, making your program more robust and easier to manage.</p>"},{"location":"interview/why-question/try-catch/#availability-in-programming-languages","title":"Availability in Programming Languages","text":"<ul> <li>Java: Supports <code>try-catch-finally</code>.</li> <li>C#: Supports <code>try-catch-finally</code>.</li> <li>Python: Uses <code>try-except-finally</code>.</li> <li>JavaScript: Supports <code>try-catch-finally</code>.</li> <li>C++: Supports <code>try-catch</code>.</li> <li>Ruby: Uses <code>begin-rescue-end</code> blocks.</li> <li>Swift: Uses <code>do-catch</code> blocks.</li> </ul>"},{"location":"math/intro/","title":"Intro","text":""},{"location":"math/intro/#intro","title":"Intro","text":"<p>As the demand for programmers increases, the supply naturally will meet with more people entering the industry everyday. However, it is a competitive industry. In order to continuously improve yourself, skill-set and increase your salary - you need to prove that you are a proficient programmer. One way you can do this is by learning the things that people don\u2019t typically know.</p> <p></p> <p>A lot of people break into the programming industry with the assumption that you do not need to know the Math behind it. Although this is somewhat true, being able to understand the logical mathematical concept behind programming will make you a more proficient programmer.</p> <p>How is that? By understanding what you are doing and what is happening. That\u2019s how.</p> <p>So let\u2019s jump right into it. What are the top 10 math concepts for programmers?</p>"},{"location":"math/intro/#1-boolean-algebra","title":"1. Boolean Algebra","text":""},{"location":"math/intro/#2-numeral-systems","title":"2. Numeral Systems","text":"<p>Computers understand numbers, and this is why they need a numeral system. A numeral system is known as a writing system used to express numbers. For example, you have these four most common number system types:</p> <ol> <li>Decimal number system (Base- 10)</li> <li>Binary number system (Base- 2)</li> <li>Octal number system (Base-8)</li> <li>Hexadecimal number system (Base- 16)</li> </ol> <p>Computers work off a Base- 2 numeral system, where the possible digits are 0 and 1. Base64 is also used to encode binary data in a string format.</p>"},{"location":"math/intro/#3-floating-point","title":"3. Floating Point","text":""},{"location":"math/intro/#4-logarithms","title":"4. Logarithms","text":""},{"location":"math/intro/#5-set-theory","title":"5. Set Theory","text":""},{"location":"math/intro/#6-combinatorics","title":"6. Combinatorics","text":""},{"location":"math/intro/#7-graph-theory","title":"7. Graph Theory","text":""},{"location":"math/intro/#8-complexity-theory","title":"8. Complexity Theory","text":"<p>Complexity theory is the study of the amount of time and memory it takes for an algorithm to run as a function of the input size. There are two types of complexities:</p> <ul> <li>Space complexity - the amount of memory an algorithm needs to run.</li> <li>Time complexity - the amount of time an algorithm needs to run.</li> </ul> <p>More people are concerned about time complexity as we can reuse the memory of an algorithm. When it comes to time complexity, the best way to measure it is by considering the number of operations the algorithm performs. Algorithms are built using if-statements and loops, therefore to reduce time spent you want to use code that has as few if-statements and loops as possible.</p> <p>Complexity theory for algorithms uses the big-o notation to help describe and provide a better understanding of the limiting behavior of an algorithm. It is used to classify algorithms by how they respond to changes in input size.</p>"},{"location":"math/intro/#9-statistics","title":"9. Statistics","text":""},{"location":"math/intro/#10-linear-algebra","title":"10. Linear Algebra","text":""},{"location":"math/intro/#reference","title":"Reference","text":"<ul> <li>Book: Math for Programming by by Ronald T. Kneusel</li> <li>Blog: 10 Math Concepts for Programmers</li> </ul>"},{"location":"paradigm/intro/","title":"Intro","text":""},{"location":"paradigm/intro/#paradigm","title":"Paradigm","text":""},{"location":"paradigm/intro/#paradigm-shift","title":"Paradigm shift","text":"<p>A person can change their paradigm, either slowly or all at once through an epiphany. You usually need a crisis to bring about an epiphany, so we prefer the first method. (1)</p> <ol> <li> <p>If you\u2019re used to object-oriented programming (OOP), then you\u2019ll be entering a new paradigm. FRP will appear a bit strange. We can claim all day that FRP is a simple idea, and it is. But simple and easy to understand aren\u2019t the same thing. The reality is that until your thinking slots into place, you will encounter some challenges.</p> <p>FRP rests on certain notions about what\u2019s important in programming that may go against your current understanding. Without these ideas, FRP is just a way of taking something that should be straightforward and doing it in an eccentric, limiting way. The claimed benefits will be remote.</p> <p>We\u2019re talking about standard functional programming ideas. If you\u2019ve done functional programming, it will be easier to learn FRP. If not, that\u2019s no problem. You don\u2019t need to know everything about functional programming to use FRP, and we\u2019ll teach you what you need to know.</p> <p>Functional Reactive Programming</p> </li> </ol>"},{"location":"paradigm/intro/#thinking-declaratively-what-the-program-is-not-what-it-does","title":"Thinking declaratively: what the program is, not what it does","text":"<p>In FRP we talk about working in the problem space rather than working in the machine space. Decades of software development have made the authors lazy. We don\u2019t want to add sequence information to our code if we don\u2019t have to. We\u2019ll only end up having to debug it.</p> <p>The sequence can be derived from dependencies, so you can write less code by leaving the sequence out altogether. You end up with a lot more \u201cwhat\u201d and a lot less \u201chow.\u201d</p> <p>This style is referred to as declarative programming: you tell the machine what the program is, not what it does. You directly describe things and the relationships between them.</p>"},{"location":"paradigm/intro/#misc-js","title":"MISC JS","text":"<p>can i console.log all web api exposed in browser</p> <p>You can\u2019t directly <code>console.log</code> all Web APIs exposed by the browser in one command, because they are part of the global environment (<code>window</code> object) and span hundreds of interfaces. However, you can inspect or iterate through the <code>window</code> object to see what\u2019s available. Here's how you can explore it:</p>"},{"location":"paradigm/intro/#view-all-properties-of-the-window-object-approximate-list-of-web-apis","title":"\ud83d\udd0d View all properties of the <code>window</code> object (approximate list of Web APIs):","text":"<pre><code>console.log(Object.getOwnPropertyNames(window));\n</code></pre> <p>This will log all enumerable and non-enumerable properties on the global window object \u2014 which includes a huge number of Web APIs (like <code>fetch</code>, <code>localStorage</code>, <code>WebSocket</code>, <code>IntersectionObserver</code>, etc.).</p>"},{"location":"paradigm/intro/#filter-only-functions-api-like","title":"\ud83e\udde0 Filter only functions (API-like):","text":"<pre><code>Object.getOwnPropertyNames(window).forEach((key) =&gt; {\n  if (typeof window[key] === \"function\") {\n    console.log(key);\n  }\n});\n</code></pre>"},{"location":"paradigm/intro/#example-list-all-global-classes-constructor-functions","title":"\ud83e\uddea Example: List all global classes (constructor functions)","text":"<pre><code>Object.getOwnPropertyNames(window).forEach((key) =&gt; {\n  try {\n    if (\n      typeof window[key] === \"function\" &amp;&amp;\n      /^\\s*class\\s+/.test(window[key].toString())\n    ) {\n      console.log(key);\n    }\n  } catch (e) {\n    // Ignore errors for restricted properties\n  }\n});\n</code></pre>"},{"location":"paradigm/intro/#tools-and-resources","title":"\ud83e\uddf0 Tools and Resources","text":"<p>If you're looking to systematically explore APIs:</p> <ul> <li>Use the MDN Web APIs Index to see documented APIs.</li> <li>Run <code>console.dir(window)</code> in DevTools and explore manually.</li> <li>Use browser extension tools like Web API Inspector or Lighthouse for runtime environment analysis.</li> </ul>"},{"location":"paradigm/intro/#limitations","title":"\ud83d\udeab Limitations","text":"<ul> <li>Some APIs are not exposed directly on <code>window</code> (e.g., <code>navigator.serviceWorker</code>).</li> <li>Some properties are browser-specific (Chrome vs Firefox vs Safari).</li> <li>Shadow realms and cross-origin restrictions can prevent full inspection.</li> </ul> <p>Would you like a categorized list (e.g., Storage APIs, DOM APIs, etc.) or help extracting them for a specific use case?</p>"},{"location":"paradigm/intro/#solved","title":"SOLVED","text":"<p><code>console.log(Object.getOwnPropertyNames(window));</code> can i see if formData is present in this</p> <p>Yes, <code>FormData</code> is a global Web API, and it will appear in the output of:</p> <pre><code>console.log(Object.getOwnPropertyNames(window));\n</code></pre> <p>However, the list is very long, so it can be hard to spot manually. To check specifically for <code>FormData</code>, you can do something like this:</p>"},{"location":"paradigm/intro/#check-if-formdata-exists","title":"\u2705 Check if FormData exists:","text":"<pre><code>if (\"FormData\" in window) {\n  console.log(\"FormData is available\");\n} else {\n  console.log(\"FormData is NOT available\");\n}\n</code></pre>"},{"location":"paradigm/intro/#or-filter-from-the-list","title":"\ud83d\udd0d Or filter from the list:","text":"<pre><code>const apis = Object.getOwnPropertyNames(window);\nconsole.log(apis.includes(\"FormData\")); // true or false\n</code></pre>"},{"location":"paradigm/intro/#confirm-its-a-constructor-function","title":"\ud83e\uddea Confirm it\u2019s a constructor (function):","text":"<pre><code>console.log(typeof window.FormData); // should be \"function\"\n</code></pre> <p>Or view the constructor:</p> <pre><code>console.log(window.FormData); // logs the FormData constructor\n</code></pre> <p>Let me know if you want to filter out all DOM-related or network-related APIs like <code>FormData</code>, <code>fetch</code>, <code>XMLHttpRequest</code>, etc.</p>"},{"location":"paradigm/intro/#filter-out-all-dom-related-only","title":"filter out all DOM-related only","text":"<p>To filter out only DOM-related APIs from <code>window</code>, you can look for constructors and objects that are part of the DOM specification.</p>"},{"location":"paradigm/intro/#heres-a-basic-way-to-filter-dom-related-apis","title":"\u2705 Here's a basic way to filter DOM-related APIs:","text":"<pre><code>const domApis = Object.getOwnPropertyNames(window).filter((name) =&gt; {\n  try {\n    const val = window[name];\n    return (\n      typeof val === \"function\" &amp;&amp;\n      // Check if it's a class or function related to DOM\n      (val.prototype instanceof Node ||\n        val.prototype instanceof EventTarget ||\n        val.prototype instanceof HTMLElement)\n    );\n  } catch (e) {\n    // Ignore properties that throw on access\n    return false;\n  }\n});\n\nconsole.log(domApis);\n</code></pre> <p>\ud83d\udca1 What this does:</p> <ul> <li> <p>It checks if the global property is a function (constructor).</p> </li> <li> <p>Then it tests if it inherits from <code>Node</code>, <code>EventTarget</code>, or <code>HTMLElement</code>, which are base classes for DOM elements.</p> </li> <li> <p>This captures DOM interfaces like <code>HTMLDivElement</code>, <code>Document</code>, <code>Element</code>, <code>Event</code>, etc.</p> </li> </ul> <p>\ud83d\udcdd Example output (browser-dependent):</p> <pre><code>[\n  \"Element\",\n  \"HTMLElement\",\n  \"Document\",\n  \"Node\",\n  \"Text\",\n  \"Comment\",\n  \"HTMLDivElement\",\n  \"HTMLInputElement\",\n  \"HTMLFormElement\",\n  \"Event\",\n  \"MouseEvent\",\n  \"KeyboardEvent\",\n  ...\n]\n</code></pre> <p>Would you like to extend this to include style-related APIs (like <code>CSSStyleDeclaration</code>) or interaction APIs (like <code>MutationObserver</code>, <code>IntersectionObserver</code>)?</p>"},{"location":"paradigm/intro/#filter-out-all-network-related-apis-only","title":"filter out all network-related APIs only","text":""},{"location":"python/args/","title":"Python Args","text":""},{"location":"python/args/#understanding-args-and-kwargs-in-python","title":"Understanding Args and Kwargs in Python","text":""},{"location":"python/args/#what-are-args","title":"What are Args?\"","text":"<ol> <li>*args are used to pass non-keyword arguments. Examples of non-keyword arguments are fun(12,14), fun(\u201cvalue1\u201d,\u201cvalue2\u201d).</li> <li>*args are usually used to prevent the program from crashing. If we do not know, numerous parameters will be passed to the function. This is used in other programming languages.</li> </ol> <p>It makes it easy to use any number of arguments without having to change your code. It provides more flexibility to your code since you can have as many arguments as you wish in the future.</p> <p>Example</p> <pre><code>def func(*args):\n    for arg in args:\n        print(arg)\n    func(11,22,33,\"Django\",\"Python\")\nlist = [11,22,33,\"Django\",\"Python\"]\n\nfunc(list)\n</code></pre> <pre><code>#OUTPUT\n11\n22\n33\nDjango\nPython\n\n#List\n[11, 22, 33, 'Django', 'Python']\n</code></pre>"},{"location":"python/args/#what-are-kwargs","title":"What are Kwargs?","text":"<p>**kwargs is a dictionary of keyword arguments. The double asterisk (<code>**</code>) symbol allows us to pass any number of arguments. A keyword argument is usually a dictionary.</p> <p>Here an example of a keyword argument is fun(a=1,b=17).</p> <p>Tips</p> <p>**kwargs are similar to *args, except you declare the variables and the amount within the same function arguments.</p>"},{"location":"python/args/#use-of-args-and-kwargs","title":"Use of Args and Kwargs","text":"<p>Args and kwargs are handy when you need to:</p> <ul> <li>Pass multiple arguments in functions</li> <li>Reduce code writing</li> <li>Make your code more readable</li> <li>Reuse the piece of code</li> </ul>"},{"location":"python/args/#using-both-args-and-kwargs-in-a-function","title":"Using Both Args and Kwargs in a Function","text":"<p>When using both args and kwargs in the same function definition, *args must occur before **kwargs.</p> <pre><code>def __init__(self, *args, **kwargs):\n</code></pre>"},{"location":"python/args/#reference","title":"Reference","text":"<ul> <li>Mastering Django A Beginner\u2019s Guide Edited by Sufyan bin Uzayr - <code>pg: 178</code></li> </ul>"},{"location":"python/content-management-system/","title":"Python CMS","text":""},{"location":"python/content-management-system/#content-management-system","title":"Content Management System","text":"<pre><code>pip install wagtail\nwagtail start mysite\ncd mysite\npip install -r requirements.txt\npython manage.py migrate\npython manage.py createsuperuser\npython manage.py runserver\n</code></pre>"},{"location":"python/content-management-system/#reference","title":"Reference","text":"<ul> <li> <p>List of content management system: wikipedia</p> </li> <li> <p>wagtail.org - official</p> </li> <li>wagtail: github</li> </ul>"}]}