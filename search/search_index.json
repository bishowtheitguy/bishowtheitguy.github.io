{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#backend-language","title":"Backend Language","text":"<ul> <li> <p> Python</p> </li> <li> <p> Laravel</p> </li> <li> <p> Go</p> </li> <li> <p> Java</p> </li> </ul> Note <p>Given the increasing prominence of artificial intelligence (AI) and its integration into backend systems, two languages with significant potential for the future of backend development in the AI domain are Python and Golang (Go).</p> <p>Python:</p> <p>Python has already established itself as a dominant language in AI and machine learning (ML) development due to its simplicity, versatility, and extensive libraries like <code>TensorFlow</code>, <code>PyTorch</code>, and <code>scikit-learn</code>. Its ease of use makes it ideal for rapid prototyping and experimentation, while its performance can be enhanced through libraries like <code>NumPy</code> and <code>Cython</code>.</p> <p>Golang (Go):</p> <p>Go is gaining traction in the AI and backend development communities due to its speed, concurrency support, and strong built-in standard library. Go's simplicity and efficiency make it well-suited for building scalable backend systems that handle AI workloads efficiently. Additionally, frameworks like <code>TensorFlow</code> and <code>gorgonia</code> provide Go bindings for AI development.</p> <p>By learning Python and Golang, you'll be well-equipped to tackle backend development tasks in the evolving landscape of AI-driven applications and systems. These languages offer complementary strengths and are likely to remain relevant in the future of AI-powered backend development.</p>"},{"location":"#question","title":"Question","text":"<p>is try catch is different in js and python beacuse i see try except in python</p> <p>Yes, try-catch in JavaScript and try-except in Python are different in syntax and usage, although they serve the same purpose of handling exceptions.</p>"},{"location":"#javascript-try-catch","title":"JavaScript Try-Catch","text":"<p>In JavaScript, the try-catch statement is used to handle exceptions. It consists of a try block where the code that might throw an exception is placed, and a catch block where the error is handled. Optionally, a finally block can be added to execute code regardless of whether an exception occurred or not.</p> <pre><code>try {\n  // Code that might throw an exception\n} catch (error) {\n  // Handle the error\n} finally {\n  // Code that runs regardless of the outcome\n}\n</code></pre>"},{"location":"#python-try-except","title":"Python Try-Except","text":"<p>In Python, the try-except statement is used for exception handling. It also includes a try block for code that might raise an exception, an except block to handle the exception, and an optional else block to execute code if no exception occurs. Like JavaScript, Python also has a finally block for code that should always run.</p> <pre><code>try:\n    # Code that might raise an exception\nexcept ExceptionType:\n    # Handle the exception\nelse:\n    # Code that runs if no exception occurs\nfinally:\n    # Code that runs regardless of the outcome\n</code></pre> <p>Key Differences</p> <ul> <li> <p>Syntax: The most obvious difference is the use of catch in JavaScript versus except in Python.</p> </li> <li> <p>Else Block: Python has an else block that allows code to run if no exception occurs, which is not available in JavaScript.</p> </li> <li> <p>Exception Handling: Both languages handle exceptions similarly, but Python's except block can specify the type of exception to catch, similar to Java.</p> </li> </ul> <p>Overall, while both constructs serve the same purpose, their syntax and additional features differ between JavaScript and Python.</p>"},{"location":"secret/","title":"Secret","text":""},{"location":"secret/#secret","title":"Secret","text":""},{"location":"secret/#email","title":"Email","text":""},{"location":"secret/#imgbb","title":"IMGBB","text":"<pre><code>https://bishowthapa.imgbb.com/\nhttps://bishowtheitguy.imgbb.com/\nhttps://bishowlovespy.imgbb.com\nhttps://maximusthapa.imgbb.com/\nhttps://javapython4me.imgbb.com/\nhttps://thedatabaseguide.imgbb.com/\nhttps://bishowlovesml.imgbb.com/\n\nno\nitsmebishowthapa@gmail.com\n</code></pre>"},{"location":"secret/#docs","title":"Docs","text":""},{"location":"secret/#1-bishowthapa33","title":"1. <code>bishowthapa33@</code>","text":"<p>Main bishow-thapa.github.io</p> <ul> <li>bt-frontend.github.io</li> <li>bt-backend.github.io</li> <li>bt-projects.github.io</li> </ul>"},{"location":"secret/#2-thejsexpert","title":"2. <code>thejsexpert@</code>","text":"<p>Main thejsexpert.github.io</p> <ul> <li>js-typescript.github.io</li> <li>js-reacts.github.io</li> <li>js-nextjs.github.io</li> <li>js-nodejs.github.io</li> <li>js-testing.github.io</li> <li>js-interviews.github.io</li> </ul>"},{"location":"secret/#3-bishowlovespython","title":"3. <code>bishowlovespython@</code>","text":"<p>Main bishowlovespython.github.io</p> <ul> <li>pypy-flask.github.io</li> <li>pypy-django.github.io</li> <li>pypy-fastapi.github.io</li> <li>pypy-testing.github.io</li> </ul>"},{"location":"secret/#4-bishowtheitguy","title":"4. <code>bishowtheitguy@</code>","text":"<p>Main bishowtheitguy.github.io</p> <ul> <li>itguy-paradigm.github.io</li> <li>itguy-dsa.github.io</li> </ul>"},{"location":"secret/#5-bishowlovesml","title":"5. <code>bishowlovesml@</code>","text":"<p>Main bishowlovesml.github.io</p> <ul> <li>ml-supervised.github.io</li> <li>ml-unsupervised.github.io</li> <li>ml-reinforcement.github.io</li> </ul>"},{"location":"secret/#6-thedatabaseguide","title":"6. <code>thedatabaseguide@</code>","text":"<p>Main thedatabaseguide.github.io</p> <ul> <li>db-sql.github.io</li> <li>db-nosql.github.io</li> <li>db-baas.github.io</li> </ul>"},{"location":"secret/#7-itsmebishow","title":"7. <code>itsmebishow@</code>","text":"<p>Main itsmebishow.github.io</p> <p>bt-mobile-apps.github.io</p> <pre><code>// DELETED\n\n- [bts-cicd.github.io](https://bts-cicd.github.io/)\n- [bts-mobile.github.io](https://bts-mobile.github.io/)\n- [bts-linux.github.io]()\n- [bts-network.github.io]()\n</code></pre>"},{"location":"secret/#8-maximusthapa33","title":"8. <code>maximusthapa33@</code>","text":"<p>Main maximus-thapa.github.io</p> <ul> <li>mt-mobile.github.io</li> <li>mt-linux.github.io</li> <li>mt-cicd.github.io</li> </ul>"},{"location":"tags/","title":"Tools","text":""},{"location":"tags/#tools","title":"Tools","text":""},{"location":"blog/","title":"Index","text":""},{"location":"blog/#blog","title":"Blog","text":""},{"location":"http/intro/","title":"Intro","text":"<p>intro</p>"},{"location":"http/types-of-api-testing/","title":"API Testing","text":""},{"location":"http/types-of-api-testing/#types-of-api-testing","title":"Types of API Testing","text":"<p>Functional, Load, Security</p> <p>The necessity for rigorous testing in API development is underscored by the diversity of the environments and conditions under which APIs operate. Testing verifies not only the code\u2019s correctness but also its efficiency and security within expected usage conditions.</p> <p>In this section, we delve into the three major categories of API testing:</p> <ol> <li>Functional,</li> <li>Load, &amp;</li> <li>Security.</li> </ol> <p>Each of these testing types serves a distinct purpose and requires a precise approach, ensuring APIs are robust and reliable within a diverse ecosystem.</p> <p>A critical tool for security testing is OWASP ZAP, which automates the detection of numerous security vulnerabilities in API endpoints. Security tests could look for issues such as SQL injections, XSS attacks, and weaknesses in authentication flows. Consider scanning an API endpoint using OWASP ZAP:</p> <pre><code>zap-cli quick-scan -r https://api.example.com\n</code></pre> <p>The report generated would typically highlight vulnerabilities:</p>"},{"location":"http/types-of-api-testing/#reference","title":"Reference","text":"<ul> <li>Learning GraphQL by Eve Porcello and Alex Banks</li> <li>Modern API Design, REST, GraphQL and Beyong by Peter Johnson</li> </ul>"},{"location":"http/OpenID/intro/","title":"Intro","text":"<p>OpenID Connect Protocol</p> <p>OpenID Connect (OIDC) is an identity layer built on top of the OAuth 2.0 framework.</p> <p>OpenID vs. OAuth2</p> <p>While <code>OAuth 2.0</code> is about resource access and sharing, <code>OIDC</code> is about user authentication. Its purpose is to give you one login for multiple sites.</p>"},{"location":"http/OpenID/intro/#overview","title":"Overview","text":"<p>OpenID and OAuth are related but distinct protocols used for authentication and authorization. Here's a breakdown of the differences:</p>"},{"location":"http/OpenID/intro/#1-openid","title":"1. OpenID:","text":"<ul> <li>Purpose: OpenID is primarily used for authentication. It allows users to sign in to third-party applications using their existing credentials from a trusted identity provider (like Google, Facebook, etc.).</li> <li>How it works: OpenID lets you use your identity from one site (the OpenID provider) to log in to other sites (relying parties). It verifies that the user is who they claim to be.</li> <li>Example: You can log into a website using your Google account, and the website will know it's you based on your Google identity.</li> <li>Version: The most common version today is OpenID Connect (OIDC), which is built on top of OAuth 2.0 to add authentication features.</li> </ul>"},{"location":"http/OpenID/intro/#2-oauth","title":"2. OAuth:","text":"<ul> <li>Purpose: OAuth is primarily used for authorization. It allows a user to grant a third-party application limited access to their resources without sharing their credentials (like username or password).</li> <li>How it works: OAuth allows users to give permissions to an application to access specific data on their behalf (e.g., accessing a user's Google Calendar without giving the app your Google login credentials). It uses tokens (access tokens and refresh tokens) for this purpose.</li> <li>Example: A third-party app asking for access to your Facebook posts or your Google Calendar without needing to know your password.</li> <li>Version: The most common version today is OAuth 2.0.</li> </ul>"},{"location":"http/OpenID/intro/#key-differences","title":"Key Differences:","text":"<ul> <li>Purpose: OpenID is for authentication (verifying identity), while OAuth is for authorization (granting access to data/resources).</li> <li>Scope: OpenID is about logging in and verifying a user, whereas OAuth is about granting permissions for a third-party app to access your resources without giving them full access to your account.</li> <li>Overlap: OpenID Connect (OIDC) is an extension of OAuth 2.0 that adds authentication capabilities to OAuth, combining both functions into a single protocol.</li> </ul>"},{"location":"http/OpenID/intro/#how-they-work-together","title":"How They Work Together:","text":"<ul> <li>OpenID Connect (OIDC) uses OAuth 2.0 for the authorization process but adds an identity layer for authentication. In other words, OIDC builds on top of OAuth to authenticate a user and provide their identity information (like an ID token).</li> </ul> So, to sum up <ul> <li>OpenID = Authentication.</li> <li>OAuth = Authorization.</li> <li>OIDC = Authentication over OAuth 2.0.</li> </ul>"},{"location":"http/OpenID/intro/#django-setup-for-openid","title":"Django Setup for OpenID","text":"<p>To implement OpenID Connect authentication in Django and Django Rest Framework (DRF), you will typically use a library like django-allauth or mozilla-django-oidc. These libraries simplify the integration of OpenID Connect into your application by handling the communication with an OpenID provider (like Google, Facebook, etc.).</p> <p>Here\u2019s a step-by-step guide for implementing OpenID Connect in Django and DRF using mozilla-django-oidc:</p> <pre><code>pip install django mozilla-django-oidc djangorestframework\n</code></pre> settings.py<pre><code>INSTALLED_APPS = [\n    # Existing apps\n    'django.contrib.sites',  # Required by django-allauth for OpenID\n    'mozilla_django_oidc',    # For OpenID Connect authentication\n    'rest_framework',         # For Django REST framework\n    'rest_framework.authtoken',  # For token-based authentication\n]\n</code></pre> <pre><code># OpenID Connect settings\nOIDC_RP_CLIENT_ID = 'your-client-id'  # Your client ID from the OpenID provider\nOIDC_RP_CLIENT_SECRET = 'your-client-secret'  # Your client secret from the OpenID provider\nOIDC_OP_AUTHORIZATION_ENDPOINT = 'https://provider.example.com/authorize'\nOIDC_OP_TOKEN_ENDPOINT = 'https://provider.example.com/token'\nOIDC_OP_USERINFO_ENDPOINT = 'https://provider.example.com/userinfo'\nOIDC_OP_JWKS_ENDPOINT = 'https://provider.example.com/jwks'  # Optional: JSON Web Key Set for verification\n\n# URL to redirect users to after login\nLOGIN_REDIRECT_URL = '/'\nLOGOUT_REDIRECT_URL = '/'\n\n# Additional Django settings\nSITE_ID = 1  # Set this to your site ID\n</code></pre> <pre><code>from django.urls import path, include\n\nurlpatterns = [\n    path('oidc/', include('mozilla_django_oidc.urls')),  # Include OIDC authentication URLs\n    # Your other URLs\n]\n</code></pre> <p>User Authentication Views</p> <p>By default, mozilla-django-oidc provides views for login, logout, and callback. You don\u2019t need to implement custom views for these; they will be available at:</p> <ul> <li><code>/oidc/login/</code>: Start the OpenID Connect login flow.</li> <li><code>/oidc/callback/</code>: Handle the callback after authentication.</li> <li><code>/oidc/logout/</code>: Log the user out.</li> </ul>"},{"location":"http/OpenID/intro/#react-setup-for-openid","title":"React Setup for OpenID","text":"<pre><code>npm install oidc-client\n</code></pre> oidc-config.js<pre><code>import { UserManager } from \"oidc-client\";\n\nconst oidcConfig = {\n  authority: \"https://your-openid-provider.com\", // The base URL of your OpenID Connect provider\n  client_id: \"your-client-id\", // Your client ID\n  redirect_uri: \"http://localhost:3000/oidc/callback\", // The redirect URL where the OIDC provider will send the user after authentication\n  response_type: \"code\", // Or \"id_token token\" for Implicit Flow\n  scope: \"openid profile email\", // The scopes you need\n  post_logout_redirect_uri: \"http://localhost:3000\", // URL to redirect to after logout\n};\n\nconst userManager = new UserManager(oidcConfig);\n\nexport default userManager;\n</code></pre>"},{"location":"http/OpenID/intro/#reference","title":"Reference","text":"<ul> <li>How to Use React OIDC in Modern Authentication Methods</li> <li>OpenID Connect and OAuth 2.0 Primer</li> <li>OpenId Connect (OIDC) with Angular</li> <li> <p>LogoutRequest has no PostLogoutRedirectUri in it when using React.js app with ... library: stackoverflow</p> </li> <li> <p>Adding OAuth to a .Net Core - React - Redux App with Identity Server 4 and Redux-oidc - Part 1</p> </li> </ul> <p></p>"},{"location":"http/OpenID/oidc-client/","title":"OIDC Client","text":""},{"location":"http/OpenID/oidc-client/#overview","title":"Overview","text":""},{"location":"http/OpenID/oidc-client/#quickstart","title":"QuickStart","text":"<pre><code>$ npm install oidc-react\n</code></pre>"},{"location":"http/OpenID/oidc-client/#usage","title":"Usage","text":"<pre><code>import { AuthProvider } from \"oidc-react\";\n\nconst oidcConfig = {\n  onSignIn: () =&gt; {\n    // Redirect?\n  },\n  authority: \"https://oidc.io/oauth\",\n  clientId: \"this-is-a-client-id\",\n  redirectUri: \"https://my-app.com/\",\n};\n\nconst Routes = () =&gt; (\n  &lt;AuthProvider {...oidcConfig}&gt;\n    &lt;Switch&gt;\n      &lt;Route exact path=\"/\"&gt;\n        &lt;Dashboard /&gt;\n      &lt;/Route&gt;\n      ...\n    &lt;/Switch&gt;\n  &lt;/AuthProvider&gt;\n);\n</code></pre>"},{"location":"http/OpenID/oidc-client/#reference","title":"Reference","text":"<ul> <li>OIDC React</li> <li>How To Implement OIDC Authentication with React Context API and React Router</li> </ul>"},{"location":"http/graphql/graphql-client/","title":"Client","text":""},{"location":"http/graphql/graphql-client/#graphql-clients","title":"GraphQL Clients","text":"<p>As we\u2019ve said numerous times, GraphQL is just a spec. It doesn\u2019t care whether you\u2019re using it with React or Vue or JavaScript or even a browser. GraphQL has opinions about a few specific topics, but beyond that, your architectural decisions are up to you. This has led to the emergence of tools to enforce some choices beyond the spec. Enter GraphQL clients.</p> <p>GraphQL clients have emerged to speed the workflow for developer teams and improve the efficiency and performance of applications. They handle tasks like network requests, data caching, and injecting data into the user interface. There are many GraphQL clients, but the leaders in the space are Relay and Apollo.</p> <p>Relay is Facebook\u2019s client that works with React and React Native. Relay aims to be the connective tissue between React components and the data that is fetched from the GraphQL server. Relay is used by Facebook, GitHub, Twitch, and more.</p> <p>Apollo Client was developed at Meteor Development Group and is a community-driven effort to build more comprehensive tooling around GraphQL. Apollo Client supports all major frontend development platforms and is framework agnostic. Companies, including Airbnb, CNBC, The New York Times, and Ticketmaster use Apollo Client in production.</p> <p>Which client is easier for a beginner to set up and learn quickly</p> <p>Between Relay and Apollo for GraphQL clients, Apollo Client is easier for a beginner to set up and learn quickly. Apollo has a simpler installation process, straightforward integration with React, and more beginner-friendly documentation and community support. Relay is more complex, with a steeper learning curve and more opinionated architecture, making it better suited for advanced or large-scale React projects rather than beginners. Therefore, Apollo is the recommended choice if you want to get started fast and learn GraphQL client development smoothly.</p>"},{"location":"http/graphql/graphql-client/#setup-apollo-client","title":"Setup Apollo Client","text":"<ol> <li> <p>Install dependencies</p> <p>Run this command in your project directory to install Apollo Client and GraphQL:</p> <pre><code>npm install @apollo/client graphql\n</code></pre> </li> <li> <p>Configure Apollo Client</p> <p>Create a new Apollo Client instance by specifying your GraphQL server endpoint (<code>uri</code>) and setting up the cache:</p> <pre><code>import { ApolloClient, InMemoryCache } from \"@apollo/client\";\n\nconst client = new ApolloClient({\n  uri: \"https://your-graphql-endpoint.com/graphql\", // Replace with your GraphQL API URL\n  cache: new InMemoryCache(),\n});\n</code></pre> </li> <li> <p>Connect Apollo Client to React</p> <p>Wrap your root React component with <code>ApolloProvider</code> and pass the client instance. This makes Apollo Client available throughout your app:</p> <pre><code>import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { ApolloProvider } from \"@apollo/client\";\nimport App from \"./App\"; // Your main app component\n\nReactDOM.render(\n  &lt;ApolloProvider client={client}&gt;\n    &lt;App /&gt;\n  &lt;/ApolloProvider&gt;,\n  document.getElementById(\"root\")\n);\n</code></pre> </li> <li> <p>Fetch data with a query</p> <p>Inside your components, use Apollo's <code>useQuery</code> hook to fetch data from your GraphQL API:</p> <pre><code>import { useQuery, gql } from \"@apollo/client\";\n\nconst GET_ITEMS = gql`\n  query GetItems {\n    items {\n      id\n      name\n    }\n  }\n`;\n\nfunction ItemList() {\n  const { loading, error, data } = useQuery(GET_ITEMS);\n\n  if (loading) return &lt;p&gt;Loading...&lt;/p&gt;;\n  if (error) return &lt;p&gt;Error &lt;/p&gt;;\n\n  return (\n    &lt;ul&gt;\n      {data.items.map(({ id, name }) =&gt; (\n        &lt;li key={id}&gt;{name}&lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  );\n}\n</code></pre> </li> </ol> <p>This setup covers the basics: installing Apollo Client, configuring it, connecting it to React, and running your first query. You can then expand with mutations, subscriptions, and advanced caching as needed.</p>"},{"location":"http/graphql/graphql-client/#most-frequent-error-in-react-18","title":"Most frequent Error in React 18","text":"<p>Error: createRoot(...): Target container is not a DOM element.</p> <p>Fix: Ensure the root container element exists (usually <code>id=\"root\"</code>), and initialize React 18 root properly:</p> <pre><code>import { createRoot } from \"react-dom/client\";\nimport { ApolloProvider } from \"@apollo/client\";\nimport client from \"./apolloClient\";\nimport App from \"./App\";\n\nconst container = document.getElementById(\"root\");\nconst root = createRoot(container);\nroot.render(\n  &lt;ApolloProvider client={client}&gt;\n    &lt;App /&gt;\n  &lt;/ApolloProvider&gt;\n);\n</code></pre> <pre><code>// apolloClient.js\nimport { ApolloClient, InMemoryCache } from \"@apollo/client\";\n\nconst client = new ApolloClient({\n  uri: \"https://your-graphql-endpoint.com/graphql\", // Replace with your GraphQL API URL\n  cache: new InMemoryCache(),\n});\n\nexport default client;\n</code></pre>"},{"location":"http/graphql/graphql-client/#reference","title":"Reference","text":"<ul> <li>Learning GraphQL by Eve Porcello and Alex Banks</li> </ul>"},{"location":"http/graphql/overview/","title":"Overview","text":""},{"location":"http/graphql/overview/#overview","title":"Overview","text":"<p>GraphQL is a query language and a runtime system that provides a more efficient and powerful way to interact with APIs. It was developed by Facebook in 2012 and open-sourced in 2015. With its introduction, GraphQL brought a paradigm shift in how developers think about and interact with data in modern applications.</p> <p>Unlike REST, where each endpoint represents a single resource and returns a fixed structure of data, GraphQL facilitates the retrieval and manipulation of data by giving clients the ability to request precisely the data they need. This precise data querying capability addresses several issues inherent in RESTful architectures, such as over-fetching and under-fetching of data.</p> <p>A GraphQL server exposes a single endpoint that is capable of understanding a variety of queries, thereby providing a flexible mechanism for clients to specify data requirements. This flexibility empowers developers to optimize network usage and reduce the number of server requests necessary to gather relevant information.</p> <p>The core component of GraphQL is its type system. At its core, GraphQL defines an application\u2019s data model as a hierarchy of types with fields that can be queried by clients. The types are defined in a language called the GraphQL Schema Definition Language (SDL). A schema is composed of object types, queries, mutations, and subscriptions which describe possible interactions with the data.</p> <p>Below is an example of a GraphQL schema definition, which illustrates its expressiveness and focus on defining strongly-typed interactions:</p> <pre><code>type Query {\n  user(id: ID!): User\n}\n\ntype User {\n  id: ID!\n  name: String\n  email: String\n}\n</code></pre> <p>In this schema, a \u2018Query\u2018 type is defined with a field \u2018user\u2018, which returns a \u2018User\u2018 object for a given \u2018id\u2018. The \u2018User\u2018 type is itself composed of several fields such as \u2018id\u2018, \u2018name\u2018, and \u2018email\u2018. Each type and field can have arguments and specifies what type of data it returns, making it explicit what clients can expect.</p>"},{"location":"http/graphql/overview/#graphql-vs-rest-a-detailed-comparison-of-queries-mutations-and-http-methods","title":"GraphQL Vs REST: A detailed Comparison of Queries, Mutations and HTTP Methods","text":"<p>In the ever-evolving landscape of API development, two major paradigms stand out:</p> <ol> <li>GraphQL &amp;</li> <li>REST.</li> </ol>"},{"location":"http/graphql/overview/#understanding-graphql-queries-vs-rest-get","title":"Understanding GraphQL Queries <code>vs.</code> REST <code>GET</code>","text":"GraphQL Queries: <p>GraphQl Queries are the primary means of fetching data in a Graphql API. What sets them apart from REST <code>GET</code> requests is the level of control they offer to the client.</p> <p>With GraphQL, clients can specify exactly which data field they need, reducing the likelihood of over-fetching or underfetching data.</p> Example of GraphQL Query.<pre><code>query {\n    user(id: \"1\") {\n        id\n        name\n        email\n    }\n}\n</code></pre> REST <code>GET</code> <p>In REST, the <code>GET</code> method is used to retrieve data from the server. Typically, a GET request to an endpoint returns a predefined set of data.</p> <p>While simple and straighforward, this approach often results in client receiving more data than they need (0verfetching) or requring additional requests to gather related data (underfetching).</p> Example REST `GET` Request.<pre><code>GET /users/1\n</code></pre>"},{"location":"http/graphql/overview/#graphql-mutations-vs-rest-post-put-patch-delete","title":"GraphQL Mutations vs. REST <code>POST</code>, <code>PUT</code>, <code>PATCH</code>, <code>DELETE</code>","text":"GraphQl Mutations <p>Mutations in GraphQl are the mechanism for modifying data on the server, whether you\u2019re creating, updating, or deleting resources, mutations handle these operations.</p> <p>Unlike REST methods, a single GraphQl mutation can perform multiple operations and return customized data in the response.</p> Example GraphQL Mutation(Create a User):<pre><code>mutation {\n    createUser(name: \"John\", email: \"john@example.com\") {\n        id\n        name\n        email\n    }\n}\n</code></pre> REST <code>POST</code> <p>The <code>POST</code> method in REST is used to create new resources on the server. The server typically responds with the created resource, including its identifier.</p> Example REST `POST` Request:<pre><code>POST /users {   \"name\": \"John\",   \"email\": \"john@example.com\" }\n</code></pre>"},{"location":"http/graphql/overview/#reference","title":"Reference","text":"<ul> <li> <p>GraphQL Vs REST: A detailed Comparison of Queries, Mutations and HTTP Methods</p> </li> <li> <p>Perplexity</p> </li> </ul>"},{"location":"http/graphql/overview/#book","title":"Book","text":"<ul> <li>Modern API Design, REST, GraphQL and Beyong by Peter Johnson</li> <li>GraphQL Best Practices</li> </ul>"},{"location":"http/graphql/rest-drawbacks/","title":"Rest Drawback","text":""},{"location":"http/graphql/rest-drawbacks/#rest-drawbacks","title":"REST Drawbacks","text":""},{"location":"http/graphql/rest-drawbacks/#overfetching","title":"Overfetching","text":"Note <p>Overfetching happens when the API returns more data than the client actually needs. For example, if you only need a user's name but the API sends the entire user profile including unnecessary fields, this wastes bandwidth, slows down the app, and consumes extra resources.</p> <pre><code>{\n  \"name\": \"Luke Skywalker\",\n  \"height\": \"172\",\n  \"mass\": \"77\",\n  \"hair_color\": \"blond\",\n  \"skin_color\": \"fair\",\n  \"eye_color\": \"blue\",\n  \"birth_year\": \"19BBY\",\n  \"gender\": \"male\",\n  \"homeworld\": \"https://swapi.co/api/planets/1/\",\n  \"films\": [\n    \"https://swapi.co/api/films/2/\",\n    \"https://swapi.co/api/films/6/\",\n    \"https://swapi.co/api/films/3/\",\n    \"https://swapi.co/api/films/1/\",\n    \"https://swapi.co/api/films/7/\"\n  ],\n  \"species\": [\"https://swapi.co/api/species/1/\"],\n  \"vehicles\": [\n    \"https://swapi.co/api/vehicles/14/\",\n    \"https://swapi.co/api/vehicles/30/\"\n  ],\n  \"starships\": [\n    \"https://swapi.co/api/starships/12/\",\n    \"https://swapi.co/api/starships/22/\"\n  ],\n  \"created\": \"2014-12-09T13:50:51.644000Z\",\n  \"edited\": \"2014-12-20T21:17:56.891000Z\",\n  \"url\": \"https://swapi.co/api/people/1/\"\n}\n</code></pre> <p>This is a huge response. The response exceeds our app\u2019s data needs. We just need the information for name, mass, and height:</p> <pre><code>{\n  \"name\": \"Luke Skywalker\",\n  \"height\": \"172\",\n  \"mass\": \"77\"\n}\n</code></pre> <p>This is a clear case of overfetching</p> <p>we\u2019re getting a lot of data back that we don\u2019t need. The client requires three data points, but we\u2019re getting back an object with 16 keys and sending information over the network that is useless.</p>"},{"location":"http/graphql/rest-drawbacks/#underfetching","title":"Underfetching","text":"<p>Our project manager just showed up at our desk and wants to add another feature to the Star Wars app. In addition to name, height, and mass, we now need to display a list of movie titles for all films that Luke Skywalker is in. After we request the data from swapi.co/api/people/1/, we still need to make additional requests for more data.</p> <p>This means we underfetched.</p> Note <p>Underfetching occurs when the API returns too little data, so the client has to make additional requests to get all the information it needs. For example, if you get only user IDs but need usernames too, you must call the API again to fetch the missing data. This increases the number of requests, slows performance, and complicates client-side code.</p> <p>In simple terms:</p> <ul> <li> <p>Overfetching = getting too much unnecessary data in one go.</p> </li> <li> <p>Underfetching = getting too little data and needing multiple calls to complete the info.</p> </li> </ul> <p>Both issues hurt performance and user experience, especially on slow connections or large datasets. Solutions often involve designing APIs that return just the right amount of data per request or using technologies like GraphQL that let clients specify exactly what data they want.</p>"},{"location":"http/graphql/rest-drawbacks/#managing-rest-endpoints","title":"Managing REST Endpoints","text":"<p>Another common complaint about REST APIs is the lack of flexibility. As the needs on the client change, you usually have to create new endpoints, and those endpoints can begin to multiply quickly.</p> <p>Development speed can be slow because setting up new endpoints often means that frontend and backend teams have more planning and communication to do with each other.</p> <p>With GraphQL, the typical architecture involves a single endpoint. The single endpoint can act as a gateway and orchestrate several data sources, but the one endpoint still makes organization of data easier.</p> <p>In this discussion of REST drawbacks, it\u2019s important to note that many organizations use GraphQL and REST together. Setting up a GraphQL endpoint that fetches data from REST endpoints is a perfectly valid way to use GraphQL. It can be a great way to incrementally adopt GraphQL at your organization.</p>"},{"location":"http/graphql/rest-drawbacks/#graphql-vs-rest","title":"\ud83c\udd9a GraphQL vs. REST","text":"Feature GraphQL REST Data Fetching Clients specify exact fields Fixed endpoints with predefined data Operations Queries (read), Mutations (write) GET, POST, PUT, DELETE Over-fetching Avoided by selecting specific fields Possible due to fixed responses Under-fetching Avoided by requesting all needed data Possible, requiring multiple requests HANDLING ERRORS <p>Successful queries return a JSON document that contains a \u201cdata\u201d key. Unsuccessful queries return a JSON document that contains an \u201cerrors\u201d key. The details of what went wrong is passed as JSON data under this key. A JSON response can contain both \u201cdata\u201d and \u201cerrors.\u201d</p> <p>\ud83d\udd0d GraphQL Queries</p> <p>GraphQL queries allow clients to request specific data from the server. Unlike REST, where clients might over-fetch or under-fetch data due to fixed endpoints, GraphQL enables clients to specify exactly what data they need.</p> <p>Example:</p> <pre><code>query {\n  user(id: \"1\") {\n    id\n    name\n    email\n  }\n}\n</code></pre> <p>In this query, the client requests the <code>id</code>, <code>name</code>, and <code>email</code> of the user with ID <code>1</code>. The server responds with only the requested fields, reducing unnecessary data transfer.</p> <p>\u270f\ufe0f GraphQL Mutations</p> <p>Mutations in GraphQL are used to modify server-side data, such as creating, updating, or deleting records. They are similar to queries but are defined under a separate root <code>mutation</code> type.</p> <p>Example:</p> <pre><code>mutation {\n  createUser(name: \"John Doe\", email: \"john.doe@example.com\") {\n    id\n    name\n    email\n  }\n}\n</code></pre> <p>This mutation creates a new user with the provided name and email, and returns the <code>id</code>, <code>name</code>, and <code>email</code> of the newly created user.</p> <ul> <li> <p>GraphQL: A Modern Approach to API Design</p> </li> <li> <p>Is GraphQL The Future?</p> </li> <li> <p>GraphQL Vs REST: A detailed Comparison of Queries, Mutations and HTTP Methods</p> </li> </ul>"},{"location":"http/graphql/rest-drawbacks/#reference","title":"Reference","text":"<ul> <li>Learning GraphQL by Eve Porcello and Alex Banks</li> <li>Modern API Design, REST, GraphQL and Beyong by Peter Johnson</li> </ul>"},{"location":"http/graphql/tools/","title":"Tools","text":""},{"location":"http/graphql/tools/#graphql-api-tools","title":"GraphQL API Tools","text":"<p>The GraphQL community has produced several open source tools that you can use to interact with GraphQL APIs. These tools allow you to write queries in the GraphQL query language, send those queries to GraphQL endpoints, and inspect the JSON response.</p>"},{"location":"http/graphql/tools/#graphiql","title":"GraphiQL","text":"<p>GraphiQL is the in-browser integrated development environment (IDE) that was created at Facebook to allow you to query and explore a GraphQL API.</p>"},{"location":"http/graphql/tools/#graphql-playground","title":"GraphQL Playground","text":"<p>Another tool for exploring GraphQL APIs is GraphQL Playground. Created by the team at Prisma, GraphQL Playground mirrors the functionality of GraphiQL and adds on a few interesting options. The easiest way to interact with a GraphQL Playground is to check it out in the browser at graphqlbin.com. After you supply an endpoint, you can interact with the data using the Playground.</p> <p>GraphQL Playground has a desktop version that you can install locally using Homebrew:</p> <pre><code>brew cask install graphql-playground\n</code></pre> <p>Or, you can just download it from the website.</p>"},{"location":"http/graphql/tools/#public-graphql-apis","title":"Public GraphQL APIs","text":"<p>One of the best ways to get started with GraphQL is to practice sending queries using a public API. Several companies and organizations provide a GraphiQL interface that you can use to query public data:</p> <ul> <li>SWAPI (the Star Wars API)</li> </ul> <p>This is a Facebook project that is a wrapper around the SWAPI REST API.</p> <ul> <li>GitHub API</li> </ul> <p>One of the largest public GraphQL APIs, the GitHub GraphQL API allows you to send queries and mutations to view and   change your live data on GitHub. You\u2019ll need to sign in with your GitHub account to interact with the data.</p> <ul> <li>Yelp</li> </ul> <p>Yelp maintains a GraphQL API that you can query using GraphiQL. You do need to create a Yelp developer account to interact with the data in the Yelp API.</p> <p>Many additional examples of public GraphQL APIs are available.</p>"},{"location":"http/graphql/tools/#reference","title":"Reference","text":"<ul> <li>Learning GraphQL by Eve Porcello and Alex Banks</li> </ul>"},{"location":"http/jwt/intro/","title":"Intro","text":"<p>jwt decoder</p> <p> </p> <p></p>"},{"location":"http/jwt/intro/#overview","title":"Overview","text":"<p>In JSON Web Tokens (JWT), there are three main parts: Header, Payload, and Signature</p> JWT HeaderJWT PayloadJWT Signature <p>The header typically contains two key pieces of information:</p> <ul> <li><code>alg</code>: The signing algorithm used, such as <code>HS256</code>, <code>RS256</code>, or <code>ES256</code> (e.g., HMAC, RSA, ECDSA).</li> <li><code>typ</code>: (Optional) The type of the token, which is usually <code>JWT</code>.</li> </ul> <pre><code>{\n    \"alg\": \"HS256\",\n    \"typ\": \"JWT\"\n}\n</code></pre> <p>The payload contains the claims, which are the statements about an entity (typically, the user) and additional data. There are three types of claims:</p> <ul> <li> <p>Registered Claims: These are predefined claims with standard meanings, such as:</p> <ul> <li><code>iss</code> (Issuer): Identifies the principal that issued the token.</li> <li><code>sub</code> (Subject): Identifies the principal that is the subject of the token (usually the user).</li> <li><code>aud</code> (Audience): Identifies the recipients that the token is intended for.</li> <li><code>exp</code> (Expiration Time): Defines the expiration time of the token.</li> <li><code>nbf</code> (Not Before): Defines the time before which the token is not valid.</li> <li><code>iat</code> (Issued At): Identifies when the token was issued.</li> </ul> </li> <li> <p>Public Claims: Custom claims that can be defined by anyone. These should be namespaced to avoid collisions.</p> </li> <li> <p>Private Claims: Claims that are agreed upon by the parties using the token, which are not registered or public but are used for specific purposes (e.g., a user\u2019s roles or permissions).</p> </li> </ul> <pre><code>{\n    \"sub\": \"1234567890\",\n    \"name\": \"John Doe\",\n    \"iat\": 1516239022\n}\n</code></pre> <p>The signature is used to verify that the sender of the JWT is who it says it is, and to ensure that the message wasn\u2019t changed along the way. It\u2019s created by taking the encoded header and payload, applying the signing algorithm, and then signing it with a secret key (HMAC) or a private key (RSA or ECDSA).</p> <p>For example, if you are using the HMAC SHA-256 algorithm (<code>HS256</code>), the signature is created like this:</p> <pre><code>HMACSHA256(\nbase64UrlEncode(header) + \".\" + base64UrlEncode(payload),\nsecret)\n</code></pre>"},{"location":"http/jwt/intro/#types-of-jwt-based-on-usage","title":"Types of JWT Based on Usage:","text":"<p>JWTs can be categorized by their intended use:</p> <ul> <li> <p>Access Tokens: These tokens are used to grant access to a resource (e.g., an API). They often have an expiration time and are usually short-lived.</p> </li> <li> <p>Refresh Tokens: These tokens are used to obtain a new access token after the original access token expires. They are typically long-lived and stored securely.</p> </li> <li> <p>ID Tokens: These are tokens used in OpenID Connect (OIDC) authentication. They contain information about the authenticated user (e.g., user profile information) and are typically used in identity verification.</p> </li> </ul>"},{"location":"http/jwt/intro/#types-of-jwt-based-on-algorithm","title":"Types of JWT Based on Algorithm:","text":"<p>JWTs also differ based on the algorithm used for signing. Some common algorithms include:</p> <ul> <li>HS256 (HMAC with SHA-256): Symmetric signing algorithm where the same secret key is used to both sign and verify the token.</li> <li>RS256 (RSA with SHA-256): Asymmetric signing algorithm using a public/private key pair.</li> <li>ES256 (ECDSA with SHA-256): Asymmetric signing algorithm using Elliptic Curve Digital Signature Algorithm.</li> </ul>"},{"location":"http/jwt/intro/#summary","title":"Summary:","text":"<p>While there are not strictly defined \"types\" of JWTs, you can think of different JWTs based on:</p> <ul> <li>Structure: Header, Payload, and Signature.</li> <li>Usage: Access Token, Refresh Token, ID Token.</li> <li>Signing Algorithms: HS256, RS256, ES256, etc.</li> </ul> <p>These are the most common ways JWTs are categorized or described.</p>"},{"location":"http/jwt/intro/#reference","title":"Reference","text":"<ul> <li>JWT Authentication : Refresh token and Access token</li> <li>What Are Refresh Tokens and How to Use Them Securel</li> <li>What Is the Lifetime of Okta Minted JSON Web Tokens(JWT)</li> <li>Significance of a JWT Refresh Token</li> </ul>"},{"location":"http/jwt/theory/","title":"Theory","text":""},{"location":"http/jwt/theory/#overview","title":"Overview","text":"<p>The theory behind access tokens and refresh tokens lies in the concept of stateless authentication and secure authorization. They are used to manage user sessions in modern web applications, ensuring that users can access resources securely without having to continuously log in.</p>"},{"location":"http/jwt/theory/#access-token","title":"Access Token","text":"<p>An access token is a short-lived credential that allows a user to access specific resources or APIs. It's issued by an authorization server after the user successfully logs in and is usually sent along with API requests to authenticate the user.</p> Characteristics of Access Tokens <ul> <li>Short-lived: Typically has a lifespan of a few minutes to an hour.</li> <li>Bearer token: It\u2019s used as a \"bearer\" token, meaning anyone with the token can access the associated resources.</li> <li>Contains user information: It often contains a claim (payload) about the user, such as user ID, roles, permissions, etc.</li> <li>Stateless: The server doesn't need to maintain a session since the token itself contains the required information.</li> </ul>"},{"location":"http/jwt/theory/#refresh-token","title":"Refresh Token","text":"<p>A refresh token is a long-lived credential used to obtain a new access token when the original access token expires. Refresh tokens are used to maintain a user\u2019s session without requiring them to log in again.</p> Characteristics of Refresh Tokens <ul> <li>Long-lived: Can last days, weeks, or even longer, depending on the configuration.</li> <li>Stored securely: Unlike access tokens, refresh tokens are stored more securely (e.g., in an HTTP-only cookie or encrypted storage).</li> <li>Not used for direct access: It is not sent to access resources directly; instead, it is used to request a new access token from the authorization server.</li> </ul>"},{"location":"http/jwt/theory/#patterns-for-token-refresh","title":"Patterns for token refresh","text":"<p>Below are common patterns used for token refresh in real-time applications:</p>"},{"location":"http/jwt/theory/#1-refresh-after-expiry-reactive-refresh","title":"1. Refresh After Expiry (Reactive Refresh)","text":"<p>How it works:</p> <ul> <li>The client attempts to use the access token for an API or real-time event.</li> <li>If the server responds with <code>401 Unauthorized</code> (indicating the token has expired), the client uses the refresh token to obtain a new access token.</li> <li>Once the new access token is retrieved, the original request is retried.</li> </ul> <p>Use cases:</p> <ul> <li>Suitable for applications with infrequent API calls or real-time events.</li> </ul> <p>Advantages:</p> <ul> <li>Minimal overhead; refreshes only when needed.</li> </ul> <p>Challenges:</p> <ul> <li>Slight delay due to the need to retry the request after obtaining a new token.</li> </ul>"},{"location":"http/jwt/theory/#2-proactive-token-refresh","title":"2. Proactive Token Refresh","text":"<p>How it works:</p> <ul> <li>The client tracks the expiration time of the access token (e.g., from the <code>exp</code> field in a JWT).</li> <li>Before the token expires (e.g., a few seconds or minutes prior), the client requests a new access token using the refresh token.</li> <li>The client seamlessly switches to the new token before making any API or real-time requests.</li> </ul> <p>Use cases:</p> <ul> <li>Applications with high-frequency API calls or real-time interactions.</li> </ul> <p>Advantages:</p> <ul> <li>Prevents disruptions or delays due to token expiration.</li> </ul> <p>Challenges:</p> <ul> <li>Adds complexity as the client needs to manage timers for token refresh.</li> </ul>"},{"location":"http/jwt/theory/#choosing-the-right-pattern","title":"Choosing the Right Pattern","text":"<p>The choice of pattern depends on the specific requirements of the real-time application:</p> Requirement Recommended Pattern High security Token rotation, proactive refresh Low latency Proactive refresh, hybrid pattern WebSocket-based communication Background refresh, embedded refresh Simple implementation Refresh after expiry <p>Each pattern comes with trade-offs, so it\u2019s essential to evaluate based on security, user experience, and the application\u2019s architecture.</p>"},{"location":"http/jwt/theory/#most-used-pattern","title":"Most used Pattern","text":"<p>In web applications, the \"Refresh After Expiry (Reactive Refresh)\" and \"Proactive Token Refresh\" patterns are the most commonly used. The choice between these patterns depends on the application's requirements and architecture:</p>"},{"location":"http/jwt/theory/#1-refresh-after-expiry-reactive-refresh_1","title":"1. Refresh After Expiry (Reactive Refresh)","text":"<p>Why it\u2019s common:</p> <ul> <li>Simpler to implement.</li> <li>Aligns with REST API standards where a <code>401 Unauthorized</code> response signals the client to refresh the token.</li> <li>Efficient in terms of server and client resource usage since tokens are only refreshed when needed.</li> </ul> <p>Common use cases:</p> <ul> <li>Single-page applications (SPAs) like e-commerce platforms, dashboards, and social networks.</li> <li>Applications with moderate or low-frequency API calls.</li> </ul>"},{"location":"http/jwt/theory/#2-proactive-token-refresh_1","title":"2. Proactive Token Refresh","text":"<p>Why it\u2019s common:</p> <ul> <li>Provides a smoother user experience by reducing the chance of users encountering a <code>401 Unauthorized</code> response.</li> <li>Useful in applications with frequent API calls, where token expiry could interrupt user interactions.</li> <li>Works well in real-time or high-frequency use cases.</li> </ul> <p>Common use cases:</p> <ul> <li>Collaborative tools (e.g., Google Docs, Figma).</li> <li>Applications with real-time updates or dashboards that make frequent requests.</li> <li>Systems requiring persistent user sessions without noticeable disruptions.</li> </ul>"},{"location":"http/jwt/theory/#other-patterns-usage","title":"Other Patterns Usage","text":"<p>Token Rotation:</p> <ul> <li>Common in applications with high-security requirements, such as financial systems or sensitive enterprise applications.</li> </ul> <p>Background Refresh (WebSocket):</p> <ul> <li>Popular in real-time applications relying on WebSockets (e.g., chat apps, trading platforms).</li> </ul> <p>Refresh on Reconnect:</p> <ul> <li>Often used in real-time WebSocket applications where connections might frequently drop and reconnect.</li> </ul> <p>Hybrid Pattern:</p> <ul> <li>Adopted by large-scale applications aiming for a balance between user experience and resource efficiency.</li> </ul>"},{"location":"http/jwt/theory/#general-trends","title":"General Trends","text":"<ul> <li>Most web applications start with \"Refresh After Expiry\" for simplicity and evolve to \"Proactive Token Refresh\" or hybrid patterns as they scale or require more seamless user experiences.</li> <li>Proactive refresh is becoming more common in SPAs and real-time applications to prevent disruptions.</li> </ul>"},{"location":"http/jwt/refreshToken/intro/","title":"Refresh Token","text":"axiosBaseQuery.js<pre><code>import axiosInstance from \"./axiosInstance\";\nimport { store } from \"@shared/store/store\";\nimport { updateRefreshToken } from \"@features/auth/services/authSlice\";\nimport logger from \"@shared/utils/logger\";\n\nconst axiosBaseQuery =\n  ({ baseUrl } = { baseUrl: \"\" }) =&gt;\n  async ({ url, method, data, params }, api, extraOptions) =&gt; {\n    try {\n      const result = await axiosInstance.test({\n        url: baseUrl + url,\n        method,\n        data,\n        params,\n      });\n      return { data: result.data };\n    } catch (axiosError) {\n      // const err = axiosError.response?.data || axiosError.message;\n      // return { error: { status: axiosError.response?.status, data: err } };\n      if (axiosError.response?.status === 401) {\n        const refreshToken = store.getState().auth.refresh;\n\n        const refreshResult = await axiosInstance.loginTest({\n          url: baseUrl + \"/auth/refresh\", // Adjust to your refresh token endpoint\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          data: { refreshToken },\n        });\n\n        if (refreshResult?.data) {\n          // Dispatch tokenReceived action with the new token\n          // api.dispatch(tokenReceived(refreshResult.data)); // Ensure correct token structure\n\n          const resultData = refreshResult?.data;\n          logger.info({ msg: \"refreshResult?.data: \", resultData });\n          api.dispatch(updateRefreshToken(refreshResult.data)); // Assuming `refresh` is part of the response\n\n          // // Retry the original request with the new token\n          // const retryResult = await axiosInstance({\n          //   url: baseUrl + url,\n          //   method,\n          //   data,\n          //   params,\n          //   headers: {\n          //     Authorization: `Bearer ${refreshResult.data.token}`, // Adjust token header if needed\n          //   },\n          // });\n\n          return { data: refreshResult.data };\n        } else {\n          // If the refresh fails, dispatch loggedOut action\n          // api.dispatch(loggedOut());\n          // return {\n          //   error: {\n          //     status: 401,\n          //     data: \"Unable to refresh token. Logged out.\",\n          //   },\n          // };\n          logger.info({ msg: \"Unable to refresh token. Logged out.\" });\n        }\n      }\n      // Return error if it's not a 401\n    }\n  };\n\nexport default axiosBaseQuery;\n</code></pre>"},{"location":"interview/draft/","title":"draft","text":""},{"location":"interview/draft/#abstract-models","title":"Abstract models","text":"<p>In Django models, when you define a class attribute Meta with <code>abstract = True</code>, you're essentially creating an abstract base class. This means that the model class itself won't be created in the database, but it serves as a blueprint for other models to inherit from.</p> <p>Here's what each part does:</p> <ul> <li> <p>Meta:</p> <p>This is a class inside a Django model that holds metadata about the model. Metadata includes things like database table name, ordering options, unique constraints, etc.</p> </li> <li> <p>abstract = True:</p> <p>When you set abstract to True within the Meta class, you're telling Django that this model is just a base class for other models. It won't create its own database table. Instead, when a subclass inherits from this abstract model, Django combines the fields from both the abstract model and the subclass into a single database table.</p> </li> </ul> models.py<pre><code>from django.db import models\n\nclass BaseModel(models.Model):\n    name = models.CharField(max_length=100)\n\n    class Meta:\n        abstract = True\n\nclass MyModel(BaseModel):\n    description = models.TextField()\n\n# Django combines the fields from BaseModel and MyModel into a single table\n# named myapp_mymodel\n</code></pre> <p>In this example, <code>BaseModel</code> is an abstract base class with the attribute <code>abstract = True</code>, so it won't create its own table. <code>MyModel</code> inherits from <code>BaseModel</code>, and Django combines the fields from both into a single table named <code>myapp_mymodel</code> in the database.</p>"},{"location":"interview/draft/#explained-in-simple","title":"Explained in Simple","text":"<p>Of course! Imagine you're building a house. You start with a blueprint, right? That blueprint tells the builders how to construct the house, but it's not an actual house itself.</p> <p>In Django models, setting <code>abstract = True</code> is like saying, \"Hey, this is just a blueprint, don't build a house based on it directly.\" Instead, other models can use this blueprint to build their own houses.</p> <p>So, when you create a model with <code>abstract = True</code>, you're making a blueprint for other models to inherit from. Those other models will combine the blueprint's instructions with their own to create a final house (or database table, in Django's case).</p>"},{"location":"interview/draft/#example","title":"Example","text":"models.py<pre><code>from django.db import models\n\nclass PostBase(models.Model):\n    title = models.CharField(max_length=100)\n    content = models.TextField()\n    created_at = models.DateTimeField(auto_now_add=True)\n\n    class Meta:\n        abstract = True\n\nclass BlogPost(PostBase):\n    author = models.CharField(max_length=50)\n\nclass NewsArticle(PostBase):\n    source = models.CharField(max_length=50)\n\n# Now you can create instances of BlogPost and NewsArticle,\n# and Django will automatically create one table for each,\n# combining the fields from PostBase and the subclass.\n</code></pre> <p>In this example:</p> <ul> <li> <p>We define an abstract base class <code>PostBase</code> with common fields like <code>title</code>, <code>content</code>, and <code>created_at</code>. We set <code>abstract = True</code> in its Meta class to indicate that it's just a blueprint.</p> </li> <li> <p>We create two concrete subclasses of <code>PostBase</code>: <code>BlogPost</code> and <code>NewsArticle</code>. Each of these adds its own specific field (<code>author</code> for <code>BlogPost</code> and <code>source</code> for <code>NewsArticle</code>).</p> </li> <li> <p>When you create instances of <code>BlogPost</code> and <code>NewsArticle</code>, Django combines the fields from <code>PostBase</code> and the subclass into separate database tables, creating a single table for each subclass (<code>BlogPost</code> and <code>NewsArticle</code>).</p> </li> </ul>"},{"location":"interview/intro/","title":"Intro","text":"Django Concepts Error Handling and Testing model inheritance"},{"location":"interview/intro/#key-django-programming-concepts","title":"Key Django Programming Concepts","text":"<ol> <li> <p>MTV (Model-Template-View) Architecture</p> <ul> <li> <p>Model: The model is the definitive source of information about your data. It contains the essential fields and behaviors of the data you\u2019re storing. Django follows the DRY Principle (Don't Repeat Yourself), so the model defines the data structure once and automatically derives things from it.</p> </li> <li> <p>Template: Django\u2019s template layer provides a designer-friendly syntax for rendering the information to be presented to the user. It allows for a separation of presentation and business logic, which is beneficial for both developers and designers.</p> </li> <li> <p>View: Views are responsible for processing user requests and returning responses. Views access the data through models and delegate the formatting of the output to the templates. In Django, a view can be a simple function or a class-based view.</p> </li> </ul> </li> <li> <p>ORM (Object-Relational Mapping)</p> <p>Django's ORM allows for the definition of data models in Python, which are then automatically translated into database tables. This abstraction layer lets you interact with your database using high-level Python code instead of SQL, making database operations safer and more intuitive.</p> </li> <li> <p>Migrations</p> <p>Migrations are Django's way of allowing database schema changes (such as adding a field, deleting a model, etc.) without requiring SQL. Migrations are Python files that describe these changes in code, allowing them to be versioned and shared with other developers.</p> </li> <li> <p>Admin Interface</p> <p>Django automatically generates a professional, production-ready admin interface for manipulating website data. This interface is dynamically created from the model definitions and provides a rapid development workflow for managing content.</p> </li> <li> <p>URLs and URLconf</p> <p>Django lets you design URLs however you want, with no framework limitations. The URLconf maps URL patterns (described as regular expressions) to your view functions. This modular URL handling system allows for a clean URL scheme and SEO-friendly web applications.</p> </li> <li> <p>Templates and Template Tags</p> <p>Templates are HTML files that allow Python-like expressions for inserting dynamic content. Template tags are Django\u2019s way of adding functionality to templates, such as looping through lists, loading static files, or applying filters to variables.</p> </li> <li> <p>Forms and ModelForms</p> <p>Django\u2019s forms handle the task of rendering HTML forms and processing submitted data. ModelForms simplify the process by creating form fields automatically for the corresponding model, making it easier to create forms for data entry without repetitive code.</p> </li> <li> <p>Authentication and Authorization</p> <p>Django comes with a built-in authentication system that handles user authentication, sessions, permissions, and user groups. It provides a way to associate users with content and to build permissions and authorization checks into your application.</p> </li> <li> <p>Middleware</p> <p>Middleware are layers of logic that Django executes during request and response processing. They're used for session management, user authentication, cross-site request forgery protection, content compression, and more.</p> </li> <li> <p>Signals</p> <p>Signals allow certain pieces of code to be notified when actions occur elsewhere in the application. They are especially useful for decoupling apps and making them extensible.</p> </li> <li> <p>Testing</p> <p>Django's built-in test framework allows for writing unit tests that ensure your application's code behaves as expected. It includes a test client for simulating requests and responses, allowing for comprehensive testing of views and interaction flows.</p> </li> <li> <p>Security Features</p> <p>Django includes numerous security features that are enabled by default, protecting against SQL Injection, Cross-site Scripting (XSS), Cross-Site Request Forgery (CSRF), and more. Django's security practices are constantly updated to address new vulnerabilities.</p> </li> <li> <p>RESTful APIs with Django REST Framework</p> <p>While Django can handle creating simple APIs using its views and serializers, Django REST Framework (DRF) provides a more flexible toolkit for building web APIs, offering features like authentication policies, serialization, and customizable endpoints.</p> </li> <li> <p>Asynchronous Support</p> <p>Starting with Django 3.1, the framework introduced support for asynchronous views, middleware, and tests, allowing developers to write async code for performance improvements in I/O-bound and high-latency operations.</p> </li> <li> <p>Deployment</p> <p>Deploying a Django application involves more than just transferring code to a server. It includes setting up a web server like Apache or Nginx, configuring a WSGI server like Gunicorn, handling static and media files, and setting up a database.</p> </li> </ol> <p>Understanding these concepts in detail can significantly enhance your ability to develop, deploy, and maintain web applications with Django, leveraging its full potential to create robust, scalable, and secure web solutions.</p>"},{"location":"interview/intro/#error-handling-and-testing","title":"Error Handling and Testing","text":"<ol> <li> <p>Exceptions</p> <p>Error handling is an essential aspect of writing reliable and robust Python programs. Python uses exceptions to handle errors and other exceptional events. An exception is an error that happens during the execution of a program. Exceptions are caught using try and except blocks.</p> <ul> <li> <p>try Block:</p> <p>You place the code that might throw an exception within a try block.</p> </li> <li> <p>except Block:</p> <p>If an exception occurs, the code inside the except block is executed. Multiple except blocks can catch different types of exceptions.</p> </li> <li> <p>else and finally:</p> <p>The else block can be used to execute code when the try block raises no exceptions, and the finally block lets you execute code, regardless of the result of the try and except blocks.</p> </li> </ul> </li> <li> <p>Assertions</p> <p>Assertions are a systematic way to check that the internal state of a program is as expected. An assertion is a sanity-check that you can turn on or turn off when you have finished testing the program. An expression is tested, and if the result comes up false, an exception is raised. Assertions are carried out through the assert statement.</p> </li> <li> <p>Unit Testing</p> <p>Python includes several modules for designing and running tests, called unit tests. Unit testing ensures that your code behaves as expected. The unittest framework, inspired by Java's JUnit, provides features for test automation, sharing of setup and shutdown code, aggregation of tests into collections, and independence of the tests from the reporting framework.</p> </li> </ol>"},{"location":"interview/intro/#using-model-inheritance","title":"Using model inheritance","text":"<p>Django supports model inheritance. It works in a similar way to standard class inheritance in Python. Django offers the following three options to use model inheritance:</p> <ul> <li>Abstract models: Useful when you want to put some common information into several models.</li> <li>Multi-table model inheritance: Applicable when each model in the hierarchy is considered a complete model by itself.</li> <li>Proxy models: Useful when you need to change the behavior of a model, for example, by including additional methods, changing the default manager, or using different meta options.</li> </ul>"},{"location":"interview/intro/#questions","title":"Questions","text":"can we use djangorestframework standalone without using django? <p>No, Django REST Framework (DRF) is tightly coupled with the Django web framework and cannot be used standalone without Django. Here are the key reasons why DRF depends on Django:</p> <ol> <li> <p>Integration with Django's Request-Response Cycle: DRF extends Django's capabilities to easily build RESTful APIs by providing serializers, views, and authentication mechanisms that integrate seamlessly with Django's request-response cycle.</p> </li> <li> <p>Dependency on Django's ORM: DRF relies on Django's ORM (Object-Relational Mapping) for database operations. Serializers in DRF are designed to work with Django models, making it easy to serialize and deserialize data between Django models and JSON or other formats.</p> </li> <li> <p>URL Routing and Views: DRF uses Django's URL routing system (urls.py) and views (views.py) to define API endpoints and handle HTTP requests. This tight integration simplifies the process of defining API routes and mapping them to view functions or class-based views.</p> </li> <li> <p>Authentication and Permissions: DRF leverages Django's authentication and permissions system to secure API endpoints. It provides ready-to-use authentication classes and permission classes that work seamlessly with Django's user authentication system.</p> </li> <li> <p>Admin Interface: DRF integrates with Django's admin interface, allowing you to manage and view API data similarly to how you manage Django models in the admin panel.</p> </li> <li> <p>Django Middleware: DRF can utilize Django middleware for additional request/response handling, logging, or other cross-cutting concerns.</p> </li> </ol> <p>Alternatives</p> <p>If you're looking to build RESTful APIs without using Django, you might consider using lightweight frameworks or libraries specifically designed for API development in Python, such as:</p> <ul> <li> <p>FastAPI: A modern, fast (high-performance), web framework for building APIs with Python 3.7+ based on standard Python type hints.</p> </li> <li> <p>Flask: A micro web framework for Python based on Werkzeug, Jinja 2, and good intentions. Flask is lightweight and flexible, making it suitable for building APIs.</p> </li> <li> <p>Falcon: A high-performance Python framework for building cloud APIs and web app backends. It's designed for speed and efficiency.</p> </li> </ul> <p>These frameworks provide alternatives to Django and can be used to develop APIs standalone without the dependency on Django's architecture and ORM. Each has its own strengths and weaknesses, so the choice depends on your specific requirements and preferences for building APIs.</p>"},{"location":"interview/intro/#reference","title":"Reference","text":"<ul> <li>PYTHON FOR WEB Development: DJANGO &amp; FLASK UNCHAINED by Hayden Van Der Post Vincent Bisette</li> <li>Django 4 By Example Fourth Edition by Antonio Mel\u00e9 : 524</li> </ul>"},{"location":"interview/core/function-signature/","title":"function signature","text":"<p>In programming languages, a function signature refers to the part of the function definition that specifies the function's name, its parameters, and, in some languages, its return type. The function signature provides essential information about how the function can be called and what arguments are required. It serves as a contract or blueprint for what the function will accept and return.</p>"},{"location":"interview/core/function-signature/#components-of-a-function-signature","title":"Components of a Function Signature","text":"<ul> <li>Function Name: The identifier by which the function is called.</li> <li>Parameters: The list of input variables (or arguments) that the function accepts. This includes the number and types of parameters.</li> <li>Return Type <code>(in some languages)</code>: Specifies the type of value the function returns.</li> </ul> PythonJavaScriptJavaC++TypeScript python<pre><code>def add(a: int, b: int) -&gt; int:\n    return a + b\n</code></pre> <ul> <li>Function Name: <code>add</code></li> <li>Parameters: <code>a</code> and <code>b</code> of type <code>int</code></li> <li>Return Type: <code>int</code></li> </ul> javascript<pre><code>function multiply(x, y) {\n    return x * y;\n}\n</code></pre> <ul> <li>Function Name: <code>multiply</code></li> <li>Parameters: <code>x</code> and <code>y</code> (types are not explicitly declared in JavaScript, though you can use TypeScript for type annotations)</li> <li>Return Type: Not explicitly declared (implicitly returns a number)</li> </ul> java<pre><code>public int subtract(int x, int y) {\n    return x - y;\n}\n</code></pre> <ul> <li>Function Name: <code>subtract</code></li> <li>Parameters: <code>x</code> and <code>y</code> of type <code>int</code></li> <li>Return Type: <code>int</code></li> </ul> cpp<pre><code>int divide(int numerator, int denominator) {\n    return numerator / denominator;\n}\n</code></pre> <ul> <li>Function Name: <code>divide</code></li> <li>Parameters: <code>numerator</code> and <code>denominator</code> of type <code>int</code></li> <li>Return Type: <code>int</code></li> </ul> typescript<pre><code>function concatenate(a: string, b: string): string {\n    return a + b;\n}\n</code></pre> <ul> <li>Function Name: <code>concatenate</code></li> <li>Parameters: <code>a</code> and <code>b</code> of type <code>string</code></li> <li>Return Type: <code>string</code></li> </ul>"},{"location":"interview/core/function-signature/#significance-of-function-signatures","title":"Significance of Function Signatures","text":"<ol> <li> <p>Code Clarity: Function signatures help make code clearer by specifying what types of inputs are expected and what the function will return.</p> </li> <li> <p>Type Checking: In statically typed languages, the function signature helps with type checking, ensuring that functions are called with the correct types of arguments.</p> </li> <li> <p>Documentation: Function signatures serve as a form of documentation for other developers to understand how to use the function properly.</p> </li> <li> <p>Overloading: In languages that support function overloading (e.g., Java, C++), the function signature allows multiple functions with the same name but different parameters.</p> </li> </ol> <p>In summary, the function signature is a fundamental aspect of function definitions that conveys the interface of the function, allowing for correct usage and integration within a program.</p>"},{"location":"interview/core/function-signature/#returning-a-value","title":"returning a value","text":"<p>In programming, returning a value from a function is often necessary to produce a result that other parts of your code can use. However, not every function needs to return a value. The decision to return a value or not depends on the function's purpose and the specific requirements of your program.</p> <ol> <li> <p>Functions That Return a Value</p> <p>Functions that are designed to produce a result or compute a value usually include a return statement. The return value can be used by the caller of the function for further processing.</p> Example in Python:<pre><code>def add(a: int, b: int) -&gt; int:\n    return a + b\n\nresult = add(5, 3)  # result is now 8\n</code></pre> Example in JavaScript:<pre><code>function multiply(x, y) {\n    return x * y;\n}\n\nlet result = multiply(4, 5);  // result is now 20\n</code></pre> </li> <li> <p>Functions That Do Not Return a Value</p> <p>Functions that perform actions rather than calculations or data transformations might not need to return a value. These functions often perform operations like printing to the console, modifying global state, or interacting with external systems.</p> Example in Python (No Return Value):<pre><code>def print_message(message: str):\n    print(message)\n\nprint_message(\"Hello, World!\")  # Prints \"Hello, World!\" to the console\n</code></pre> Example in JavaScript (No Return Value):<pre><code>function logMessage(message) {\n    console.log(message);\n}\n\nlogMessage(\"Hello, World!\");  // Logs \"Hello, World!\" to the console\n</code></pre> </li> </ol> What Happens If a Function Does Not Return a Value? <ul> <li> <p>Default Return Value: In languages like <code>Python</code> and <code>JavaScript</code>, if a function does not explicitly return a value, it returns a default value:</p> <ul> <li>Python: The default return value is <code>None</code>.</li> <li>JavaScript: The default return value is <code>undefined</code>.</li> </ul> Python Example:<pre><code>def no_return():\n    pass\n\nresult = no_return()  # result is None\n</code></pre> JavaScript Example:<pre><code>function noReturn() {\n    // no return statement\n}\n\nlet result = noReturn();  // result is undefined\n</code></pre> </li> <li> <p>Utility: Functions that do not return a value are useful for performing side effects:</p> <ul> <li>Logging: Writing information to the console or a log file.</li> <li>Modifying State: Changing global variables or updating class properties.</li> <li>Interacting with External Systems: Sending data to a server or writing to a file.</li> </ul> </li> <li> <p>Control Flow: Some functions control the flow of execution without returning a value, such as functions that raise exceptions or terminate a program.</p> Python Example:<pre><code>def terminate_program():\n    raise SystemExit(\"Terminating program.\")\n</code></pre> JavaScript Example:<pre><code>function terminateProgram() {\n    throw new Error(\"Terminating program.\");\n}\n</code></pre> </li> </ul> <p>Summary</p> <ul> <li> <p>Functions That Return Values: Used when the result of a computation or data transformation needs to be used later in the code.</p> </li> <li> <p>Functions That Do Not Return Values: Used when the function performs an action or produces a side effect, such as logging or modifying state.</p> </li> </ul> <p>Whether or not to use a <code>return</code> statement depends on the function's purpose and how it fits into the overall design of your program. Functions without return values can still be valuable for their side effects and control flow capabilities.</p>"},{"location":"interview/core/function-signature/#languages-that-return-default-values","title":"Languages That Return Default Values","text":"<p>In programming, whether a function returns a default value when no explicit return statement is provided depends on the language. Here's a breakdown of some popular programming languages and their behavior regarding default return values:</p> Languages That Return Default Values <ol> <li> <p>Python</p> <ul> <li>Default Return Value: <code>None</code></li> <li>Reason: In Python, if a function does not have an explicit <code>return</code> statement, it implicitly returns <code>None</code>. This design simplifies function definitions by ensuring that all functions return a value, making it easier to handle cases where a function might not need to return a value but still maintains a consistent interface.</li> </ul> python<pre><code>def do_nothing():\n    pass\n\nresult = do_nothing()  # result is None\n</code></pre> </li> <li> <p>JavaScript</p> <ul> <li>Default Return Value: <code>undefined</code></li> <li>Reason: In JavaScript, if a function does not have an explicit <code>return</code> statement, it implicitly returns <code>undefined</code>. This behavior aligns with JavaScript's loose typing and dynamic nature, where <code>undefined</code> is used to represent an uninitialized or non-existent value.</li> </ul> javascrip<pre><code>function doNothing() {\n    // no return statement\n}\n\nlet result = doNothing();  // result is undefined\n</code></pre> </li> </ol> Languages Where Default Return Values Are Not Applicable <ol> <li> <p>C++</p> <ul> <li>Default Return Value: Undefined behavior if the return type is not <code>void</code></li> <li>Reason: In C++, if a function that is supposed to return a value (i.e., not of type <code>void</code>) does not have a return statement, it leads to undefined behavior. This is because C++ expects an explicit return value for non-<code>void</code> functions to maintain well-defined program behavior.</li> </ul> cpp<pre><code>int add(int a, int b) {\n    // no return statement\n}\n\nint result = add(1, 2);  // Undefined behavior\n</code></pre> </li> <li> <p>Java</p> <ul> <li>Default Return Value: None (Functions must explicitly return a value)</li> <li>Reason: In Java, methods with non-<code>void</code> return types must include an explicit <code>return</code> statement. The language enforces this rule to ensure that methods conform to their declared return types and avoid potential runtime errors.</li> </ul> java<pre><code>public int add(int a, int b) {\n    return a + b;\n}\n\nint result = add(1, 2);  // result is 3\n</code></pre> </li> </ol> <p>Why Default Return Values Are Used</p> <ol> <li> <p>Language Design Philosophy: Default return values often reflect the language's design philosophy and goals. For example, Python and JavaScript favor flexibility and simplicity, while languages like Swift and Java emphasize explicitness and type safety.</p> </li> <li> <p>Error Handling: Providing default return values can help prevent errors related to uninitialized values. In dynamically typed languages like Python and JavaScript, <code>None</code> and <code>undefined</code> serve as indicators of missing or uninitialized values.</p> </li> <li> <p>Conciseness: Languages like Ruby use implicit returns to enable more concise and readable code, reducing boilerplate and making it easier to write expressive functions.</p> </li> <li> <p>Safety and Clarity: Languages like Swift and Java require explicit return values to ensure that function contracts are clear and enforced, reducing the risk of unexpected behavior and improving code safety.</p> </li> </ol> <p>Summary</p> <ul> <li>Languages with Default Values: Python (<code>None</code>), JavaScript (<code>undefined</code>), Ruby (last evaluated expression)</li> <li>Languages without Default Values: Swift, C++, Java (require explicit return values for non-void functions)</li> </ul> <p>The behavior of default return values reflects the language's design goals, such as simplicity, safety, and expressiveness.</p>"},{"location":"interview/core/memonic/","title":"Memonic","text":"<p>memonic</p>"},{"location":"interview/core/serialization-versus-deserialization/","title":"Serialization","text":"<p>An object is something that lives in the application memory. We can invoke its method or access its attributes in our application. </p> <p>However, when we want to transfer or store an object, we will have to convert it into a storable or transferrable format, and that format will be a stream of bytes. It can then be stored in a text file, in a database, or be transmitted over the internet. </p> <p>The process of converting an object to a stream of bytes is called serialization. This stream of bytes persists the state of the object so that it can be recreated later. The recreation of the object from a stream of bytes is called deserialization.</p>"},{"location":"interview/core/serialization-versus-deserialization/#reference","title":"Reference","text":"<ul> <li>Python API Development Fundamentals - pg 126</li> </ul>"},{"location":"interview/core/theory/","title":"Theory","text":"<p>There are three main categories of cloud computing services out there.</p> <ol> <li>Software as a Service (SaaS)</li> <li>Platform as a Service (PaaS)</li> <li>Infrastructure as a Service (IaaS)</li> </ol> Microservices <p>DEFINITION</p> <p>A microservice is an architectural style in which components of a system are designed as independently deployable services. Microservices are designed around well-defined business subdomains, and they talk to each other using lightweight protocols, such as HTTP.</p> <p>DEFINITION</p> <p>A monolith is an architectural pattern in which the whole application is deployed as a single build.</p> <ul> <li></li> </ul>"},{"location":"interview/core/theory/#marshalling-vs-serilization","title":"Marshalling vs Serilization","text":"<p>Marshalling and serialization are related concepts in Django, but they are not exactly the same. Both involve converting data from one format to another, but they are used in slightly different contexts and with different purposes.</p>"},{"location":"interview/core/theory/#serialization","title":"Serialization","text":"<p>Serialization in Django refers to the process of converting complex data types, such as Django model instances, into a format that can be easily rendered into JSON, XML, or other content types. This is particularly useful for API development, where data needs to be sent over the network in a standard format.</p> <p>In Django, serialization is often achieved using the serializers module from the Django REST framework (DRF). Here's a basic example of how serialization works in Django:</p> <pre><code>from rest_framework import serializers\nfrom myapp.models import MyModel\n\nclass MyModelSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = MyModel\n        fields = '__all__'\n</code></pre> <p>This serializer can then be used to convert MyModel` instances to and from JSON, XML, or other formats.</p>"},{"location":"interview/core/theory/#marshalling","title":"Marshalling","text":"<p>Marshalling is a broader term that refers to the process of transforming data structures or objects into a format that can be stored or transmitted and later reconstructed. While marshalling is a general concept used in many programming languages and frameworks, in the context of Django, it can be seen as part of the serialization process, especially when dealing with data transmission over networks.</p> <p>In the Django REST framework, marshalling is effectively handled by the serializers, as they not only serialize data into specific formats but also ensure the data is in a suitable structure for transmission and storage.</p>"},{"location":"interview/core/theory/#differences","title":"Differences","text":"<ul> <li>Scope: Serialization is specifically about converting objects to a different format (like JSON or XML). Marshalling, on the other hand, is a broader concept that includes serialization but also involves preparing data for transmission and ensuring it can be correctly reconstructed.</li> <li>Context: In Django, serialization is the more commonly used term and is often associated with the Django REST framework and APIs. Marshalling is more of a general concept in computer science that encompasses serialization.</li> </ul> <ul> <li>Marshalling: wikipedia</li> </ul>"},{"location":"interview/leetcode/intro/","title":"Intro","text":"<p>leetcode</p>"},{"location":"interview/why-question/control-statement-detail/","title":"Control Statement Detail","text":""},{"location":"interview/why-question/control-statement-detail/#why","title":"Why","text":"<p>Understanding when to use <code>if...else</code> versus <code>switch</code> statements depends largely on the specifics of the problem you're solving and the nature of the conditions you need to handle. Here's a deeper dive into each:</p>"},{"location":"interview/why-question/control-statement-detail/#ifelse-statement","title":"<code>if...else</code> Statement","text":"<p>When to Use:</p> <ol> <li> <p>Complex Conditions:</p> <p>Use <code>if...else</code> when the conditions you're evaluating are complex or not easily expressed with discrete values. For example, if you need to compare a variable to ranges or perform complex logical operations, <code>if...else</code> is more flexible.</p> <pre><code>if (age &lt; 13) {\n    // Child\n} else if (age &gt;= 13 &amp;&amp; age &lt; 20) {\n    // Teenager\n} else {\n    // Adult\n}\n</code></pre> </li> <li> <p>Multiple Conditions:</p> <p>When you have multiple conditions that don\u2019t fall into a simple pattern or are based on different variables.</p> <pre><code>if (temperature &gt; 30 &amp;&amp; humidity &gt; 70) {\n    // Hot and humid\n} else if (temperature &gt; 30) {\n    // Hot but not humid\n} else if (humidity &gt; 70) {\n    // Humid but not hot\n} else {\n    // Neither hot nor humid\n}\n</code></pre> </li> <li> <p>Non-Discrete Values:</p> <p>When you need to compare a variable against a condition that is not just a single value, such as ranges or complex expressions.</p> <pre><code>if (score &gt;= 90) {\n    // A\n} else if (score &gt;= 80) {\n    // B\n} else if (score &gt;= 70) {\n    // C\n} else {\n    // F\n}\n</code></pre> </li> </ol> <p>Advantages:</p> <ul> <li>Flexibility: Handles a broader range of conditions.</li> <li>Complex Expressions: Allows for complex logical expressions and comparisons.</li> </ul> <p>Disadvantages:</p> <ul> <li>Readability: Can become less readable with many conditions or complex logic.</li> </ul>"},{"location":"interview/why-question/control-statement-detail/#switch-statement","title":"<code>switch</code> Statement","text":"<p>When to Use:</p> <ol> <li> <p>Discrete Values:</p> <p>Use <code>switch</code> when you are comparing a variable to a fixed set of discrete values (like enums or constants). It's particularly useful when the variable is of integral types (like integers or enumerated values) and you have a limited number of cases to handle.</p> <pre><code>switch (day) {\n    case 1:\n        // Monday\n        break;\n    case 2:\n        // Tuesday\n        break;\n    case 3:\n        // Wednesday\n        break;\n    // ...\n    default:\n        // Default case\n}\n</code></pre> </li> <li> <p>Clarity with Many Cases:</p> <p>When you have many discrete conditions that would otherwise require a long series of <code>if...else</code> statements, <code>switch</code> can improve readability and organization.</p> <pre><code>switch (userRole) {\n    case \"admin\":\n        // Admin functionality\n        break;\n    case \"user\":\n        // User functionality\n        break;\n    case \"guest\":\n        // Guest functionality\n        break;\n    default:\n        // Default functionality\n}\n</code></pre> </li> <li> <p>Performance:</p> <p>In some cases, especially with large numbers of cases, switch statements can be more performant than <code>if...else</code> chains because some compilers optimize them using jump tables or hash tables.</p> </li> </ol> <p>Advantages:</p> <ul> <li>Readability: Cleaner and more organized when handling many discrete values.</li> <li>Performance: Potentially optimized for performance by compilers or interpreters.</li> </ul> <p>Disadvantages:</p> <ul> <li>Limited Flexibility: Typically only suitable for discrete values; more complex conditions are difficult to handle.</li> <li>Limited Types: In many languages, <code>switch</code> statements are restricted to integers, enums, or specific types.</li> </ul>"},{"location":"interview/why-question/control-statement-detail/#summary","title":"Summary","text":"<ul> <li>Use <code>if...else</code> for complex conditions, ranges, and when you need flexibility with logical expressions.</li> <li>Use <code>switch</code> when you have a variable with a discrete set of values and want a clear, organized way to handle multiple specific cases.</li> </ul> <p>In many modern languages, <code>switch</code> statements have evolved to handle more complex scenarios (like pattern matching in newer versions of languages like Java and C#), but <code>if...else</code> remains the go-to for more intricate decision-making.</p>"},{"location":"interview/why-question/control-statement-detail/#depth","title":"Depth","text":"<p>Detailed Analysis of if...else vs. switch</p>"},{"location":"interview/why-question/control-statement-detail/#ifelse-statement_1","title":"<code>if...else</code> Statement","text":"<p>When to Use:</p> <p>Complex Conditions and Logical Operations:</p> <ul> <li> <p><code>if...else</code> is ideal for situations where conditions are not simply a match against discrete values but involve more complex logic. This includes comparisons, logical operations, or combinations of different variables.</p> </li> <li> <p>Example:</p> <pre><code>if (temperature &gt; 30 &amp;&amp; humidity &gt; 70) {\n    // Handle hot and humid conditions\n} else if (temperature &gt; 30) {\n    // Handle only hot conditions\n} else if (humidity &gt; 70) {\n    // Handle only humid conditions\n} else {\n    // Handle other conditions\n}\n</code></pre> </li> </ul> <p>Non-Discrete Conditions:</p> <ul> <li> <p>Use <code>if...else</code> when conditions involve ranges or intervals. <code>switch</code> is typically less suited for this kind of logic.</p> </li> <li> <p>Example:</p> <pre><code>if (score &gt;= 90) {\n    // Grade A\n} else if (score &gt;= 80) {\n    // Grade B\n} else if (score &gt;= 70) {\n    // Grade C\n} else {\n    // Grade F\n}\n</code></pre> </li> </ul> <p>Boolean Logic and Multiple Variables:</p> <ul> <li> <p>When decisions depend on multiple variables or complex boolean expressions, <code>if...else</code> provides the flexibility to handle these conditions.</p> </li> <li> <p>Example:</p> <pre><code>if (isWeekend &amp;&amp; !isHoliday) {\n    // Weekend but not a holiday\n} else if (isWeekend &amp;&amp; isHoliday) {\n    // Weekend and a holiday\n} else {\n    // Not a weekend\n}\n</code></pre> </li> </ul> <p>Advantages:</p> <ul> <li>Flexibility: Handles complex conditions and logical operations.</li> <li>Readability: Suitable for situations where the logic is intricate and cannot be expressed as discrete values.</li> </ul> <p>Disadvantages:</p> <ul> <li>Verbosity: For a large number of discrete cases, <code>if...else</code> can become verbose and harder to manage.</li> </ul>"},{"location":"interview/why-question/control-statement-detail/#switch-statement_1","title":"<code>switch</code> Statement","text":"<p>When to Use:</p> <p>Discrete Values and Enumerations:</p> <ul> <li> <p>Use <code>switch</code> when you need to select one of many predefined discrete values (such as enums or constants) based on the value of a single variable.</p> </li> <li> <p>Example:</p> <pre><code>switch (day) {\n    case 1:\n        // Monday\n        break;\n    case 2:\n        // Tuesday\n        break;\n    case 3:\n        // Wednesday\n        break;\n    // Additional cases\n    default:\n        // Default case for unmatched values\n}\n</code></pre> </li> </ul> <p>Improved Readability with Multiple Cases:</p> <ul> <li> <p><code>switch</code> enhances readability and maintainability when dealing with multiple discrete values. It organizes the logic more clearly compared to multiple <code>if...else</code> statements.</p> </li> <li> <p>Example:</p> <pre><code>switch (statusCode) {\n    case 200:\n        // OK\n        break;\n    case 404:\n        // Not Found\n        break;\n    case 500:\n        // Internal Server Error\n        break;\n    default:\n        // Handle other status codes\n}\n</code></pre> </li> </ul> <p>Potential Performance Benefits:</p> <ul> <li>In some cases, <code>switch</code> statements can be optimized by the compiler to use jump tables or hash tables, leading to performance improvements over a series of <code>if...else</code> statements. This is more noticeable with a large number of cases.</li> </ul> <p>Advantages:</p> <ul> <li>Clarity: Provides a clear and organized structure for handling multiple discrete cases.</li> <li>Performance: Can be optimized for performance in some scenarios with many cases.</li> </ul> <p>Disadvantages:</p> <ul> <li>Limited Flexibility: Typically only handles discrete values and is less suited for complex logical conditions.</li> <li>Language Limitations: In some languages, <code>switch</code> statements have limitations regarding the types of values they can handle (e.g., they might not support strings or complex types directly).</li> </ul>"},{"location":"interview/why-question/control-statement-detail/#language-documentation-and-guidelines","title":"Language Documentation and Guidelines","text":"<p>Programming languages often define the behavior and limitations of if...else and switch statements in their documentation, but the specifics can vary. Here\u2019s how you might find guidance in language documentation:</p> <ul> <li>Syntax and Examples: Documentation usually provides the syntax and examples of <code>if...else</code> and <code>switch</code> statements.</li> <li>Best Practices: Many languages have best practices and performance considerations related to these constructs. For example, documentation may suggest using <code>switch</code> for a large number of discrete cases due to performance reasons.</li> <li>Language-Specific Limitations: Documentation may also highlight language-specific constraints or enhancements. For example, newer versions of languages might extend the capabilities of <code>switch</code> (like pattern matching in recent versions of Python and Java).</li> </ul>"},{"location":"interview/why-question/control-statement-detail/#practical-considerations","title":"Practical Considerations","text":"<p>When choosing between <code>if...else</code> and <code>switch</code>, consider the following practical aspects:</p> <ol> <li> <p>Number of Conditions:</p> <ul> <li>Use <code>switch</code> for a large number of discrete cases for better readability.</li> <li>Use <code>if...else</code> for fewer cases or more complex conditions.</li> </ul> </li> <li> <p>Condition Complexity:</p> <ul> <li>Use <code>if...else</code> for conditions involving ranges, intervals, or logical combinations.</li> <li>Use <code>switch</code> for straightforward, discrete value comparisons.</li> </ul> </li> <li> <p>Maintainability:</p> <ul> <li>Consider which construct will be easier to maintain and understand, especially as the codebase grows.</li> </ul> </li> </ol> <p>In summary, while <code>if...else</code> provides flexibility and is suitable for complex or non-discrete conditions, <code>switch</code> offers clarity and potential performance benefits for discrete value comparisons. The choice between them often depends on the nature of the conditions and the specific requirements of the problem at hand.</p>"},{"location":"interview/why-question/control-statement-detail/#discrete-non-discrete-values","title":"Discrete &amp; Non-Discrete Values","text":"<p>Understanding \"discrete values\" and \"enumerations\" versus \"non-discrete\" values is crucial for choosing the right control flow construct in programming. Let\u2019s delve into these concepts:</p>"},{"location":"interview/why-question/control-statement-detail/#discrete-values","title":"Discrete Values","text":"<p>Discrete values refer to distinct, separate values that are clearly defined and typically belong to a finite set. These values are usually distinct and separate from each other, making them ideal for use with constructs like <code>switch</code> statements.</p> <p>Characteristics:</p> <ul> <li>Finite Set: Discrete values come from a limited and defined set of possible values.</li> <li>Distinct: Each value is unique and separate from the others.</li> <li>Integral Types: Often, discrete values are integers or enumerated types (enums).</li> </ul> <p>Examples:</p> <ul> <li> <p>Integer Constants: Values like <code>1</code>, <code>2</code>, <code>3</code>, etc.</p> <pre><code>switch (dayOfWeek) {\n    case 1: // Monday\n    case 2: // Tuesday\n    case 3: // Wednesday\n    // ...\n    default: // Handle unexpected values\n}\n</code></pre> </li> <li> <p>Enumerations: Named constants that represent a set of related values.</p> <pre><code>enum Day {\n    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY\n}\n\nDay today = Day.MONDAY;\n\nswitch (today) {\n    case MONDAY:\n        // Handle Monday\n        break;\n    case TUESDAY:\n        // Handle Tuesday\n        break;\n    // Other cases\n}\n</code></pre> </li> <li> <p>String Literals: In some languages, <code>switch</code> can handle string literals if the language supports it.</p> <pre><code>switch (color) {\n    case \"red\":\n        // Handle red\n        break;\n    case \"green\":\n        // Handle green\n        break;\n    case \"blue\":\n        // Handle blue\n        break;\n    default:\n        // Handle other colors\n}\n</code></pre> </li> </ul>"},{"location":"interview/why-question/control-statement-detail/#non-discrete-values","title":"Non-Discrete Values","text":"<p>Non-discrete values refer to values that do not come from a finite or well-defined set. These values are often more complex, continuous, or range-based, making them less suitable for constructs like <code>switch</code> and better suited for <code>if...else statements</code>.</p> <p>Characteristics:</p> <ul> <li>Continuous or Range-Based: Non-discrete values can be continuous (e.g., floating-point numbers) or represent a range of values.</li> <li>Complex Conditions: They often require more complex conditions or comparisons, which are better handled by <code>if...else</code>.</li> </ul> <p>Examples:</p> <ul> <li> <p>Ranges: Values that fall within a certain range, such as ages, temperatures, etc.</p> <pre><code>if (temperature &lt; 0):\n    # Handle freezing conditions\nelse if (temperature &gt;= 0 &amp;&amp; temperature &lt;= 30):\n    # Handle cold to moderate conditions\nelse:\n    # Handle hot conditions\n</code></pre> </li> <li> <p>Complex Conditions: Situations involving logical combinations or relationships between multiple variables.</p> <pre><code>if (age &lt; 13) {\n    // Child\n} else if (age &gt;= 13 &amp;&amp; age &lt; 20) {\n    // Teenager\n} else if (age &gt;= 20 &amp;&amp; age &lt; 60) {\n    // Adult\n} else {\n    // Senior\n}\n</code></pre> </li> </ul>"},{"location":"interview/why-question/control-statement-detail/#summary_1","title":"Summary","text":"<p>Discrete Values:</p> <ul> <li>Come from a finite set of distinct, separate values.</li> <li>Ideal for <code>switch</code> statements due to their clear boundaries and discrete nature.</li> <li>Examples: specific integers, enumerations, named constants.</li> </ul> <p>Non-Discrete Values:</p> <ul> <li>May involve ranges, intervals, or more complex conditions.</li> <li>Better suited for <code>if...else</code> statements, which can handle a wider range of logical conditions.</li> <li>Examples: ranges of numbers, conditions involving multiple variables.</li> </ul> <p>Choosing between <code>if...else</code> and <code>switch</code> often depends on whether your conditions involve discrete, clearly defined values or more complex, continuous conditions.</p>"},{"location":"interview/why-question/control-statement-detail/#example","title":"Example","text":"<p>Sure, let\u2019s go through examples of both discrete and non-discrete values in different programming contexts to illustrate their use:</p>"},{"location":"interview/why-question/control-statement-detail/#discrete-values_1","title":"Discrete Values","text":"<p>Discrete values are distinct, separate, and finite values. They are ideal for switch statements or similar constructs where each value is clearly defined and separate from the others.</p> Example 1Example 2 <p>Integer Constants (Switch Statement)</p> <p>Imagine a scenario where you need to handle different days of the week:</p> <pre><code>int dayOfWeek = 3; // Assume 1 = Monday, 2 = Tuesday, etc.\n\nswitch (dayOfWeek) {\n    case 1:\n        System.out.println(\"Monday\");\n        break;\n    case 2:\n        System.out.println(\"Tuesday\");\n        break;\n    case 3:\n        System.out.println(\"Wednesday\");\n        break;\n    case 4:\n        System.out.println(\"Thursday\");\n        break;\n    case 5:\n        System.out.println(\"Friday\");\n        break;\n    case 6:\n        System.out.println(\"Saturday\");\n        break;\n    case 7:\n        System.out.println(\"Sunday\");\n        break;\n    default:\n        System.out.println(\"Invalid day\");\n}\n</code></pre> <p>Here, <code>dayOfWeek</code> is a discrete value from a finite set of integers, making it suitable for a <code>switch</code> statement.</p> <p>Enumerations (Switch Statement)</p> <p>Consider an <code>enum</code> representing different types of user roles:</p> <pre><code>enum UserRole {\n    ADMIN, USER, GUEST\n}\n\nUserRole role = UserRole.ADMIN;\n\nswitch (role) {\n    case ADMIN:\n        System.out.println(\"Admin role\");\n        break;\n    case USER:\n        System.out.println(\"User role\");\n        break;\n    case GUEST:\n        System.out.println(\"Guest role\");\n        break;\n    default:\n        System.out.println(\"Unknown role\");\n}\n</code></pre> <p>In this example, <code>UserRole</code> is an enumeration with a finite set of named constants, making it ideal for a <code>switch</code> statement.</p>"},{"location":"interview/why-question/control-statement-detail/#non-discrete-values_1","title":"Non-Discrete Values","text":"<p>Non-discrete values can be ranges, continuous values, or involve complex conditions that don\u2019t fit neatly into a finite set. These are better handled with <code>if...else</code> statements.</p> Example 1Example 2 <p>Range of Values (If-Else Statement)</p> <p>Consider a scenario where you need to classify ages into different categories:</p> <pre><code>age = 25\n\nif age &lt; 13:\n    print(\"Child\")\nelif 13 &lt;= age &lt; 20:\n    print(\"Teenager\")\nelif 20 &lt;= age &lt; 60:\n    print(\"Adult\")\nelse:\n    print(\"Senior\")\n</code></pre> <p>Here, <code>age</code> is a non-discrete value because it falls into a range of categories. This requires <code>if...else</code> to handle the different age ranges.</p> <p>Complex Conditions (If-Else Statement)</p> <p>Imagine you need to make decisions based on a combination of temperature and humidity:</p> <pre><code>let temperature = 85; // in Fahrenheit\nlet humidity = 75; // in percentage\n\nif (temperature &gt; 80 &amp;&amp; humidity &gt; 70) {\n    console.log(\"Hot and humid\");\n} else if (temperature &gt; 80) {\n    console.log(\"Hot but not humid\");\n} else if (humidity &gt; 70) {\n    console.log(\"Humid but not hot\");\n} else {\n    console.log(\"Mild conditions\");\n}\n</code></pre> <p>In this case, <code>temperature</code> and <code>humidity</code> are non-discrete values because they involve ranges and combinations, making <code>if...else</code> a better fit.</p>"},{"location":"interview/why-question/control-statement-detail/#summary_2","title":"Summary","text":"<ul> <li>Discrete Values: Clear, distinct, and finite. Suitable for <code>switch</code> statements. Examples include integers representing days of the week or enumerations.</li> <li>Non-Discrete Values: Involve ranges, intervals, or complex conditions. Suitable for <code>if...else</code> statements. Examples include age ranges or conditions based on multiple variables.</li> </ul> <p>Understanding whether your values are discrete or non-discrete helps you choose the most appropriate control flow construct for clarity and efficiency.</p>"},{"location":"interview/why-question/control-statement/","title":"Control Statement","text":""},{"location":"interview/why-question/control-statement/#overview","title":"Overview","text":"<p>Most programming languages have a common set of control statements that help manage the flow of a program. The most fundamental ones are:</p> <ol> <li> <p>Conditional Statements:</p> <p>These allow a program to make decisions and execute different code based on conditions. The most common conditional statements are:</p> <ul> <li><code>if</code>: Executes a block of code if its condition is true.</li> <li><code>else</code>: Executes a block of code if the preceding <code>if</code> condition is false.</li> <li><code>else if</code>: Tests additional conditions if the previous conditions are false.</li> <li><code>switch</code>: Chooses one of many code blocks to execute based on the value of an expression.</li> </ul> </li> <li> <p>Looping Statements:</p> <p>These execute a block of code multiple times based on certain conditions. Common looping statements include:</p> <ul> <li><code>for</code>: Repeats a block of code a specific number of times.</li> <li><code>while</code>: Repeats a block of code as long as a condition remains true.</li> <li><code>do...while</code>: Similar to <code>while</code>, but it guarantees that the block of code will be executed at least once before the condition is tested.</li> </ul> </li> <li> <p>Jump Statements: These alter the flow of control in a program.</p> <ul> <li><code>break</code>: Exits from the nearest loop or switch statement.</li> <li><code>continue</code>: Skips the rest of the current iteration in a loop and proceeds with the next iteration.</li> <li><code>return</code>: Exits from the current function and optionally returns a value.</li> </ul> </li> <li> <p>Exception Handling (in some languages):</p> <p>Manages errors and exceptional situations that occur during runtime.</p> <ul> <li><code>try...catch</code>: Attempts to execute a block of code and handles exceptions if they occur.</li> <li><code>finally</code>: Executes code after the <code>try</code> and `catch`` blocks, regardless of whether an exception was thrown.</li> </ul> </li> </ol> <p>These statements are foundational and present in varying forms across different programming languages, though their exact syntax and additional features may differ.</p>"},{"location":"interview/why-question/intro/","title":"Intro","text":"<p>intro</p>"},{"location":"interview/why-question/try-catch/","title":"try catch","text":""},{"location":"interview/why-question/try-catch/#what-is-try-catch","title":"What is Try-Catch?","text":"<p>In programming, try-catch is a construct used to handle exceptions or errors that may occur during the execution of a program. It allows you to separate normal code from error-handling code, making your program more robust and easier to manage.</p>"},{"location":"interview/why-question/try-catch/#availability-in-programming-languages","title":"Availability in Programming Languages","text":"<ul> <li>Java: Supports <code>try-catch-finally</code>.</li> <li>C#: Supports <code>try-catch-finally</code>.</li> <li>Python: Uses <code>try-except-finally</code>.</li> <li>JavaScript: Supports <code>try-catch-finally</code>.</li> <li>C++: Supports <code>try-catch</code>.</li> <li>Ruby: Uses <code>begin-rescue-end</code> blocks.</li> <li>Swift: Uses <code>do-catch</code> blocks.</li> </ul>"},{"location":"math/intro/","title":"Intro","text":""},{"location":"math/intro/#intro","title":"Intro","text":"<p>As the demand for programmers increases, the supply naturally will meet with more people entering the industry everyday. However, it is a competitive industry. In order to continuously improve yourself, skill-set and increase your salary - you need to prove that you are a proficient programmer. One way you can do this is by learning the things that people don\u2019t typically know.</p> <p></p> <p>A lot of people break into the programming industry with the assumption that you do not need to know the Math behind it. Although this is somewhat true, being able to understand the logical mathematical concept behind programming will make you a more proficient programmer.</p> <p>How is that? By understanding what you are doing and what is happening. That\u2019s how.</p> <p>So let\u2019s jump right into it. What are the top 10 math concepts for programmers?</p>"},{"location":"math/intro/#1-boolean-algebra","title":"1. Boolean Algebra","text":""},{"location":"math/intro/#2-numeral-systems","title":"2. Numeral Systems","text":"<p>Computers understand numbers, and this is why they need a numeral system. A numeral system is known as a writing system used to express numbers. For example, you have these four most common number system types:</p> <ol> <li>Decimal number system (Base- 10)</li> <li>Binary number system (Base- 2)</li> <li>Octal number system (Base-8)</li> <li>Hexadecimal number system (Base- 16)</li> </ol> <p>Computers work off a Base- 2 numeral system, where the possible digits are 0 and 1. Base64 is also used to encode binary data in a string format.</p>"},{"location":"math/intro/#3-floating-point","title":"3. Floating Point","text":""},{"location":"math/intro/#4-logarithms","title":"4. Logarithms","text":""},{"location":"math/intro/#5-set-theory","title":"5. Set Theory","text":""},{"location":"math/intro/#6-combinatorics","title":"6. Combinatorics","text":""},{"location":"math/intro/#7-graph-theory","title":"7. Graph Theory","text":""},{"location":"math/intro/#8-complexity-theory","title":"8. Complexity Theory","text":"<p>Complexity theory is the study of the amount of time and memory it takes for an algorithm to run as a function of the input size. There are two types of complexities:</p> <ul> <li>Space complexity - the amount of memory an algorithm needs to run.</li> <li>Time complexity - the amount of time an algorithm needs to run.</li> </ul> <p>More people are concerned about time complexity as we can reuse the memory of an algorithm. When it comes to time complexity, the best way to measure it is by considering the number of operations the algorithm performs. Algorithms are built using if-statements and loops, therefore to reduce time spent you want to use code that has as few if-statements and loops as possible.</p> <p>Complexity theory for algorithms uses the big-o notation to help describe and provide a better understanding of the limiting behavior of an algorithm. It is used to classify algorithms by how they respond to changes in input size.</p>"},{"location":"math/intro/#9-statistics","title":"9. Statistics","text":""},{"location":"math/intro/#10-linear-algebra","title":"10. Linear Algebra","text":""},{"location":"math/intro/#reference","title":"Reference","text":"<ul> <li>Book: Math for Programming by by Ronald T. Kneusel</li> <li>Blog: 10 Math Concepts for Programmers</li> </ul>"},{"location":"python/args/","title":"Python Args","text":""},{"location":"python/args/#understanding-args-and-kwargs-in-python","title":"Understanding Args and Kwargs in Python","text":""},{"location":"python/args/#what-are-args","title":"What are Args?\"","text":"<ol> <li>*args are used to pass non-keyword arguments. Examples of non-keyword arguments are fun(12,14), fun(\u201cvalue1\u201d,\u201cvalue2\u201d).</li> <li>*args are usually used to prevent the program from crashing. If we do not know, numerous parameters will be passed to the function. This is used in other programming languages.</li> </ol> <p>It makes it easy to use any number of arguments without having to change your code. It provides more flexibility to your code since you can have as many arguments as you wish in the future.</p> <p>Example</p> <pre><code>def func(*args):\n    for arg in args:\n        print(arg)\n    func(11,22,33,\"Django\",\"Python\")\nlist = [11,22,33,\"Django\",\"Python\"]\n\nfunc(list)\n</code></pre> <pre><code>#OUTPUT\n11\n22\n33\nDjango\nPython\n\n#List\n[11, 22, 33, 'Django', 'Python']\n</code></pre>"},{"location":"python/args/#what-are-kwargs","title":"What are Kwargs?","text":"<p>**kwargs is a dictionary of keyword arguments. The double asterisk (<code>**</code>) symbol allows us to pass any number of arguments. A keyword argument is usually a dictionary.</p> <p>Here an example of a keyword argument is fun(a=1,b=17).</p> <p>Tips</p> <p>**kwargs are similar to *args, except you declare the variables and the amount within the same function arguments.</p>"},{"location":"python/args/#use-of-args-and-kwargs","title":"Use of Args and Kwargs","text":"<p>Args and kwargs are handy when you need to:</p> <ul> <li>Pass multiple arguments in functions</li> <li>Reduce code writing</li> <li>Make your code more readable</li> <li>Reuse the piece of code</li> </ul>"},{"location":"python/args/#using-both-args-and-kwargs-in-a-function","title":"Using Both Args and Kwargs in a Function","text":"<p>When using both args and kwargs in the same function definition, *args must occur before **kwargs.</p> <pre><code>def __init__(self, *args, **kwargs):\n</code></pre>"},{"location":"python/args/#reference","title":"Reference","text":"<ul> <li>Mastering Django A Beginner\u2019s Guide Edited by Sufyan bin Uzayr - <code>pg: 178</code></li> </ul>"},{"location":"python/content-management-system/","title":"Python CMS","text":""},{"location":"python/content-management-system/#content-management-system","title":"Content Management System","text":"<pre><code>pip install wagtail\nwagtail start mysite\ncd mysite\npip install -r requirements.txt\npython manage.py migrate\npython manage.py createsuperuser\npython manage.py runserver\n</code></pre>"},{"location":"python/content-management-system/#reference","title":"Reference","text":"<ul> <li> <p>List of content management system: wikipedia</p> </li> <li> <p>wagtail.org - official</p> </li> <li>wagtail: github</li> </ul>"}]}